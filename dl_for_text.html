

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>11. 자연어 처리 &#8212; Deep Learning with Python(2판)</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=ac02cc09edc035673794" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=ac02cc09edc035673794" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=ac02cc09edc035673794" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=ac02cc09edc035673794" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=ac02cc09edc035673794" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=ac02cc09edc035673794" />
  <script src="_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=ac02cc09edc035673794"></script>

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'dl_for_text';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="12. 생성 모델" href="generative_dl.html" />
    <link rel="prev" title="10. 시계열 분석" href="dl_for_timeseries.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
  
    <p class="title logo__title">Deep Learning with Python(2판)</p>
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="what_is_deep_learning.html">1. 딥러닝 소개</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="building_blocks_of_NN.html">2. 신경망 기본 구성 요소</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="tf_tensor.html">2.7. 부록: 텐서플로우 텐서</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="keras_and_tf.html">3. 케라스와 텐서플로우</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started_with_neural_networks.html">4. 신경망 활용 처음부터 끝까지: 분류와 회귀</a></li>
<li class="toctree-l1"><a class="reference internal" href="fundamentals_of_ml.html">5. 머신러닝 모델 훈련 기법</a></li>
<li class="toctree-l1"><a class="reference internal" href="unversal_workflow_of_ml.html">6. 머신러닝 작업 흐름 일반</a></li>
<li class="toctree-l1"><a class="reference internal" href="working_with_keras.html">7. 케라스 신경망 모델 활용법</a></li>
<li class="toctree-l1"><a class="reference internal" href="computer_vision_intro.html">8. 컴퓨터 비전 기초: 합성곱 신경망</a></li>
<li class="toctree-l1"><a class="reference internal" href="computer_vision_advanced.html">9. 고급 컴퓨터 비전</a></li>
<li class="toctree-l1"><a class="reference internal" href="dl_for_timeseries.html">10. 시계열 분석</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">11. 자연어 처리</a></li>
<li class="toctree-l1"><a class="reference internal" href="generative_dl.html">12. 생성 모델</a></li>
<li class="toctree-l1"><a class="reference internal" href="best_practices.html">13. 딥러닝 실전 적용</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/codingalzi/dlp2" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/codingalzi/dlp2/issues/new?title=Issue%20on%20page%20%2Fdl_for_text.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/dl_for_text.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>자연어 처리</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">11.1. 자연어 처리 소개</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">11.2. 텍스트 데이터 전처리</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">11.2.1. 문장 표준화</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">11.2.2. 토큰화</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">11.2.3. 어휘 색인화</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">11.3. 단어 주머니와 단어 임베딩</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#imdb">11.3.1. IMDB 영화 후기 데이터셋 준비</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">11.3.2. 단어 주머니 활용법</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">11.3.3. 시퀀스 활용법</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">11.3.3.1. 원-핫 단어 벡터</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">11.3.3.2. 단어 임베딩</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#glove">11.3.3.3. GloVe 단어 임베딩</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">11.4. 트랜스포머 아키텍처</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">11.4.1. 셀프 어텐션</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">11.4.2. 멀티헤드 어텐션</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">11.4.3. 트랜스포머 인코더</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id16">11.4.4. 트랜스포머 사용 기준</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id17">11.5. 시퀀스-투-시퀀스 학습</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id18">11.6. 참고 문헌</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id19">11.7. 연습 문제</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="ch-nlp">
<span id="id1"></span><h1><span class="section-number">11. </span>자연어 처리<a class="headerlink" href="#ch-nlp" title="Permalink to this heading">#</a></h1>
<p><strong>감사의 글</strong></p>
<p>아래 내용은 프랑소와 숄레의
<a class="reference external" href="https://github.com/fchollet/deep-learning-with-python-notebooks">Deep Learning with Python(2판)</a>의
소스코드 내용을 참고해서 작성되었습니다.
자료를 공개한 저자에게 진심어린 감사를 전합니다.</p>
<p><strong>소스코드</strong></p>
<p>여기서 언급되는 코드를
<a class="reference external" href="https://colab.research.google.com/github/codingalzi/dlp2/blob/master/notebooks/NB-dl_for_text_1.ipynb">(구글 코랩) 자연어 처리 1부</a>와
<a class="reference external" href="https://colab.research.google.com/github/codingalzi/dlp2/blob/master/notebooks/NB-dl_for_text_2.ipynb">(구글 코랩) 자연어 처리 2부</a>에서
직접 실행할 수 있다.</p>
<p><strong>주요 내용</strong></p>
<p>1부:</p>
<ul class="simple">
<li><p>단어 주머니</p></li>
<li><p>단어 임베딩</p></li>
</ul>
<p>2부:</p>
<ul class="simple">
<li><p>트랜스포머 아키텍처</p></li>
<li><p>시퀀스-투-시퀀스 학습</p></li>
</ul>
<h1>1부</h1><p>단어 주머니와 단어 임베딩을 활용하는 모델을 알아본다.</p>
<section id="id2">
<h2><span class="section-number">11.1. </span>자연어 처리 소개<a class="headerlink" href="#id2" title="Permalink to this heading">#</a></h2>
<p>파이썬, 자바, C, C++, C#, 자바스크립트 등 컴퓨터 프로그래밍언어와 구분하기 위해
일상에서 사용되는 한국어, 영어 등을 <strong>자연어</strong><font size='2'>natural language</font>라
부른다.</p>
<p>자연어의 특성상 정확한 분석을 위한 알고리즘을 구현하는 일은 사실상 매우 어렵다.
딥러닝 기법이 활용되기 이전까지는 적절한 규칙을 구성하여 자연어를 이해하려는
수 많은 시도가 있어왔지만 별로 성공적이지 않았다.</p>
<p>1990년대부터 인터넷으로부터 구해진 엄청난 양의 텍스트 데이터에 머신러닝 기법을
적용하기 시작했다. 단, 주요 목적이 <strong>언어의 이해</strong>가 아니라
아래 예제들처럼 입력 문장을 분석하여
<strong>통계적으로 유용한 정보를 예측</strong>하는 방향으로 수정되었다.</p>
<ul class="simple">
<li><p>문장 분류: “이 문장의 주제는?”</p></li>
<li><p>내용 필터링: “욕설이 포함되었나?”</p></li>
<li><p>감성 분석: “내용이 긍정이야 부정이야?”</p></li>
<li><p>언어 모델링: “이 문장에 이어 어떤 단어가 있어야 하지?”</p></li>
<li><p>번역: “이거를 한국어로 어떻게 말해?”</p></li>
<li><p>요약: “이 기사를 한 줄로 요약하면?”</p></li>
</ul>
<p>이와 같은 분석을 <strong>자연어 처리</strong><font size='2'>Natural Language Processing</font>라 하며
단어, 문장, 문단 등에서 찾을 수 있는 패턴을  인식하려 시도한다.</p>
<p><strong>머신러닝 활용</strong></p>
<p>자연어 처리를 위해 1990년대부터 시작된 머신러닝 활용의 변화과정은 다음과 같다.</p>
<ul class="simple">
<li><p>1990 - 2010년대 초반:
결정트리, 로지스틱 회귀 모델이 주로 활용됨.</p></li>
<li><p>2014-2015: LSTM 등 시퀀스 처리 알고리즘 활용 시작</p></li>
<li><p>2015-2017: (양방향) 순환신경망이 기본적으로 활용됨.</p></li>
<li><p>2017-2018: 트랜스포머<font size='2'>transformer</font> 모델이 최고의 성능 발휘하며,
많은 난제들을 해결함. 현재 가장 많이 활용되는 모델임.</p></li>
</ul>
</section>
<section id="id3">
<h2><span class="section-number">11.2. </span>텍스트 데이터 전처리<a class="headerlink" href="#id3" title="Permalink to this heading">#</a></h2>
<p>딥러닝 모델은 문장 자체를 처리할 수 없다.
따라서 문장을 수치형 텐서로 변환하는 <strong>문장 벡터화</strong><font size='2'>text vectorization</font> 과정이 요구되며
보통 다음 세 단계를 따른다.</p>
<ol class="arabic simple">
<li><p><strong>문장 표준화</strong><font size='2'>text standardization</font>: 소문자화, 마침표 제거 등등</p></li>
<li><p><strong>토큰화</strong><font size='2'>tokenization</font>: 기본 단위의 <strong>유닛</strong><font size='2'>units</font>으로 쪼개기.
문자, 단어, 단어 집합 등이 토큰으로 활용됨.</p></li>
<li><p><strong>어휘 색인화</strong><font size='2'>vocabulary indexing</font>: 토큰 각각을 하나의 수치형 벡터로 변환.</p></li>
</ol>
<p>아래 그림은 문장 벡터화의 기본적인 과정을 잘 보여준다.</p>
<div align="center"><img src="https://drek4537l1klr.cloudfront.net/chollet2/Figures/11-01.png" style="width:60%;"></div>
<p><div style="text-align: center">&lt;그림 출처: <a href="https://www.manning.com/books/deep-learning-with-python-second-edition">Deep Learning with Python(2판)</a>&gt;</div></p><section id="id4">
<h3><span class="section-number">11.2.1. </span>문장 표준화<a class="headerlink" href="#id4" title="Permalink to this heading">#</a></h3>
<p>다음 두 문장을 표준화를 통해 동일한 문장으로 변환해보자.</p>
<ul class="simple">
<li><p>“sunset came. i was staring at the Mexico sky. Isnt nature splendid??”</p></li>
<li><p>“Sunset came; I stared at the México sky. Isn’t nature splendid?”</p></li>
</ul>
<p>예를 들어 다음과 같은 표준화 기법을 사용할 수 있다.</p>
<ul class="simple">
<li><p>모두 소문자화</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.</span></code>, <code class="docutils literal notranslate"><span class="pre">;</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code>, <code class="docutils literal notranslate"><span class="pre">'</span></code> 등 특수 기호 제거</p></li>
<li><p>특수 알파벳 변환: “é”를 “e”로, “æ”를 “ae”로 등등</p></li>
<li><p>동사/명사의 기본형 활용: “cats”를 “[cat]”로, “was staring”과 “stared”를 “[stare]”로 등등.</p></li>
</ul>
<p>그러면 위 두 문장 모두 아래 문장으로 변환된다.</p>
<ul class="simple">
<li><p>“sunset came i [stare] at the mexico sky isnt nature splendid”</p></li>
</ul>
<p>표준화 과정을 통해 어느 정도의 정보를 상실하게 되지만
학습해야할 내용을 줄여 일반화 성능이 보다 좋은 모델을 훈련시키는 장점이 있다.
하지만 분석 목적에 따라 사용되는 표준화 기법이 달라질 수 있음에 주의해야 한다.
예를 들어 인터뷰 기사의 경우 물음표(<code class="docutils literal notranslate"><span class="pre">?</span></code>)는 제거하면 안된다.</p>
</section>
<section id="id5">
<h3><span class="section-number">11.2.2. </span>토큰화<a class="headerlink" href="#id5" title="Permalink to this heading">#</a></h3>
<p>문장 표준화 이후 데이터 분석의 기본 단위인 토큰으로 쪼개야 한다.
보통 아래 세 가지 방식 중에 하나를 사용한다.</p>
<ul class="simple">
<li><p>단어 기준 토큰화</p>
<ul>
<li><p>공백으로 구분된 단어들로 쪼개기.</p></li>
<li><p>경우에 따라 동사 어근과 어미를 구분하기도 함: “star+ing”, “call+ed” 등등</p></li>
</ul>
</li>
<li><p>N-그램 토큰화</p>
<ul>
<li><p>N-그램 토큰: 연속으로 위치한 N 개(이하)의 단어 묶음</p></li>
<li><p>예제: “the cat”, “he was” 등은 2-그램(바이그램) 토큰이다.</p></li>
</ul>
</li>
<li><p>문자 기준 토큰화</p>
<ul>
<li><p>하나의 문자를 하나의 토큰으로 지정.</p></li>
<li><p>문장 생성, 음성 인식 등에서 활용됨.</p></li>
</ul>
</li>
</ul>
<p>일반적으로 문자 기준 토큰화는 잘 사용되지 않는다.
여기서도 단어 기준과 N-그램 토큰화만 이용한다.</p>
<ul class="simple">
<li><p>단어 기준 토큰화: 단어들의 순서를 중요시하는 <strong>순차 모델</strong><font size='2'>sequence models</font>을 사용할 경우 주로 활용된다.</p></li>
<li><p>N-그램 토큰화: 단어들의 순서를 별로 상관하지 않는 <strong>단어 주머니</strong><font size='2'>bag-of-words</font>
모델을 사용할 경우 주로 활용된다.</p>
<ul>
<li><p>N-그램: 단어들 사이의 순서에 대한 지엽적 정보를 어느 정도 유지한다.</p></li>
<li><p>일종의 특성 공학<font size='2'>feature engineering</font> 기법이며,
트랜스포머 등 최신 기법에는 활용되지 않는다.</p></li>
</ul>
</li>
</ul>
<p>단어 주머니<font size='2'>bag-of-words</font>는 N-그램으로 구성된 집합을 의미하며
<strong>N-그램 주머니</strong>라고도 불린다.
예를 들어 “the cat sat on the mat.” 문장에 대한
2-그램(바이그램) 집합과 3-그램 집합은 각각 다음과 같다.</p>
<ul>
<li><p>2-그램(바이그램) 집합</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s2">&quot;the&quot;</span><span class="p">,</span> <span class="s2">&quot;the cat&quot;</span><span class="p">,</span> <span class="s2">&quot;cat&quot;</span><span class="p">,</span> <span class="s2">&quot;cat sat&quot;</span><span class="p">,</span> <span class="s2">&quot;sat&quot;</span><span class="p">,</span>
<span class="s2">&quot;sat on&quot;</span><span class="p">,</span> <span class="s2">&quot;on&quot;</span><span class="p">,</span> <span class="s2">&quot;on the&quot;</span><span class="p">,</span> <span class="s2">&quot;the mat&quot;</span><span class="p">,</span> <span class="s2">&quot;mat&quot;</span><span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<ul>
<li><p>3-그램 집합</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s2">&quot;the&quot;</span><span class="p">,</span> <span class="s2">&quot;the cat&quot;</span><span class="p">,</span> <span class="s2">&quot;cat&quot;</span><span class="p">,</span> <span class="s2">&quot;cat sat&quot;</span><span class="p">,</span> <span class="s2">&quot;the cat sat&quot;</span><span class="p">,</span>
<span class="s2">&quot;sat&quot;</span><span class="p">,</span> <span class="s2">&quot;sat on&quot;</span><span class="p">,</span> <span class="s2">&quot;on&quot;</span><span class="p">,</span> <span class="s2">&quot;cat sat on&quot;</span><span class="p">,</span> <span class="s2">&quot;on the&quot;</span><span class="p">,</span>
<span class="s2">&quot;sat on the&quot;</span><span class="p">,</span> <span class="s2">&quot;the mat&quot;</span><span class="p">,</span> <span class="s2">&quot;mat&quot;</span><span class="p">,</span> <span class="s2">&quot;on the mat&quot;</span><span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="id6">
<h3><span class="section-number">11.2.3. </span>어휘 색인화<a class="headerlink" href="#id6" title="Permalink to this heading">#</a></h3>
<p>일반적으로 먼저 훈련셋에 포함된 모든 토큰들의 색인(인덱스)을 생성한 다음에
원-핫, 멀티-핫 인코딩 등의 방식을 사용하여 수치형 텐서로 변환한다.</p>
<p><a class="reference internal" href="getting_started_with_neural_networks.html#ch-getting-started-with-neural-networks"><span class="std std-numref">4장</span></a>에서 언급한 대로
보통 사용 빈도가 높은 2만 또는 3만 개의 단어만을 대상으로 어휘 색인화를 진행한다.
당시에 IMDB 영화 후기 데이터셋을 불러올 때
<code class="docutils literal notranslate"><span class="pre">num_words=10000</span></code>을 사용하여 사용 빈도수가 상위 1만 등 안에 들지 않는 단어는
영화 후기에서 무시되도록 하였다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">tensorflow.keras.datasets</span> <span class="kn">import</span> <span class="n">imdb</span>
<span class="p">(</span><span class="n">train_data</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">),</span> <span class="p">(</span><span class="n">test_data</span><span class="p">,</span> <span class="n">test_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">imdb</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span><span class="n">num_words</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
</pre></div>
</div>
<p>케라스의 imdb 데이터셋은 이미 문장 벡터화 전처리가 완료된 상태였다.
즉 영화 후기가 정수들의 리스트로 이미 변환된 상태였다.
하지만 여기서는 영어 문장으로 작성된 원본 영화후기로 구성된 imdb 데이터셋을
다운로드하여 문장 벡터화 전처리를 직접 수행하는 단계부터 살펴보려 한다.</p>
<p><strong>0과 1의 특별한 기능</strong></p>
<p>문장을 변환한 벡터에 사용되는 0과 1은 특별한 기능을 수행한다.</p>
<ul>
<li><p>미등록 어휘 인덱스 기능: 어휘 색인에 미등록된(out-of-vocabulary, OOV) 단어는 모두 1로 지정된다.
그런 단어는 일반 문장으로 재번역되는 경우 “[UNK]”, 즉 모르는 단어로 처리된다.</p></li>
<li><p>패딩 기능: 문장의 길이를 통일시키기 위해 0을 패딩으로 사용한다.
0을 <strong>마스크 토큰</strong><font size='2'>mask token</font>이라 부르기도 하며,
모델 훈련과정에서 무시되도록 할 수 있다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mi">5</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span> <span class="mi">124</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">65</span><span class="p">],</span>
 <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span>  <span class="mi">21</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">]]</span>
</pre></div>
</div>
</li>
</ul>
<div class="proof example admonition" id="exp-textvectorization">
<p class="admonition-title"><span class="caption-number">Example 11.1 </span> (<code class="docutils literal notranslate"><span class="pre">TextVectorization</span></code> 층 활용법)</p>
<section class="example-content" id="proof-content">
<p>케라스의 <code class="docutils literal notranslate"><span class="pre">TextVectorization</span></code> 층을 이용하여 문장 벡터화를 진행할 수 있다.
아래 코드는 <code class="docutils literal notranslate"><span class="pre">TextVectorization</span></code> 층 구성에 사용되는 주요 기본 설정을 보여준다.
표준화와 토큰화 방식을 임의로 지정해서 활용할 수도 있지만 여기서는 자세히 다루지 않는다.</p>
<ul class="simple">
<li><p>표준화: <code class="docutils literal notranslate"><span class="pre">standardize='lower_and_strip_punctuation'</span></code> (소문자화와 마침표 등 제거)</p></li>
<li><p>토큰화: <code class="docutils literal notranslate"><span class="pre">split='whitespace'</span></code> (단어 기준 쪼개기), <code class="docutils literal notranslate"><span class="pre">ngrams=None</span></code> (n-그램 미사용)</p></li>
<li><p>출력 모드: <code class="docutils literal notranslate"><span class="pre">output_mode=&quot;int&quot;</span></code> (정수 인코딩)</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tensorflow.keras.layers</span> <span class="kn">import</span> <span class="n">TextVectorization</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">text_vectorization</span> <span class="o">=</span> <span class="n">TextVectorization</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">standardize</span><span class="o">=</span><span class="s1">&#39;lower_and_strip_punctuation&#39;</span><span class="p">,</span>  <span class="c1"># 기본값</span>
<span class="gp">... </span>    <span class="n">split</span><span class="o">=</span><span class="s1">&#39;whitespace&#39;</span><span class="p">,</span>                         <span class="c1"># 기본값</span>
<span class="gp">... </span>    <span class="n">ngrams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>                                <span class="c1"># 기본값</span>
<span class="gp">... </span>    <span class="n">output_mode</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<p>예를 들어, 아래 데이터셋을 이용하여 문장 벡터화에 사용될 어휘 색인을 생성해보자.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="s2">&quot;I write, erase, rewrite&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s2">&quot;Erase again, and then&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s2">&quot;A poppy blooms.&quot;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">]</span>
</pre></div>
</div>
<p>어휘 색인은 <code class="docutils literal notranslate"><span class="pre">adapt()</span></code> 메서드를 이용하여 만든다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text_vectorization</span><span class="o">.</span><span class="n">adapt</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
</pre></div>
</div>
<p>생성된 어휘 색인은 다음과 같다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vocabulary</span> <span class="o">=</span> <span class="n">text_vectorization</span><span class="o">.</span><span class="n">get_vocabulary</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vocabulary</span>
<span class="go">[&#39;&#39;,</span>
<span class="go"> &#39;[UNK]&#39;,</span>
<span class="go"> &#39;erase&#39;,</span>
<span class="go"> &#39;write&#39;,</span>
<span class="go"> &#39;then&#39;,</span>
<span class="go"> &#39;rewrite&#39;,</span>
<span class="go"> &#39;poppy&#39;,</span>
<span class="go"> &#39;i&#39;,</span>
<span class="go"> &#39;blooms&#39;,</span>
<span class="go"> &#39;and&#39;,</span>
<span class="go"> &#39;again&#39;,</span>
<span class="go"> &#39;a&#39;]</span>
</pre></div>
</div>
<p>생성된 어휘 색인을 활용하여 새로운 문장을 벡터화 해보자.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">test_sentence</span> <span class="o">=</span> <span class="s2">&quot;I write, rewrite, and still rewrite again&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoded_sentence</span> <span class="o">=</span> <span class="n">text_vectorization</span><span class="p">(</span><span class="n">test_sentence</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">encoded_sentence</span><span class="p">)</span>
<span class="go">tf.Tensor([ 7  3  5  9  1  5 10], shape=(7,), dtype=int64)</span>
</pre></div>
</div>
<p>벡터화된 텐서로부터 문장을 복원하면 표준화된 문장이 생성된다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">inverse_vocab</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">vocabulary</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoded_sentence</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">inverse_vocab</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">encoded_sentence</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">decoded_sentence</span><span class="p">)</span>
<span class="go">i write rewrite and [UNK] rewrite again</span>
</pre></div>
</div>
</section>
</div><div class="warning admonition">
<p class="admonition-title"><code class="docutils literal notranslate"><span class="pre">TextVectorization</span></code> 층과 GPU</p>
<p><code class="docutils literal notranslate"><span class="pre">TextVectorization</span></code> 층은 GPU 또는 TPU에서 지원되지 않는다.
따라서 모델 구성에 직접 사용하는 방식은 모델의 훈련을
늦출 수 있기에 권장되지 않는다.
여기서는 대신에 데이터셋 전처리를 모델 구성과 독립적으로 처리하는 방식을 이용한다.</p>
<p>하지만 훈련이 완성된 모델을 실전에 배치할 경우 <code class="docutils literal notranslate"><span class="pre">TextVectorization</span></code> 층을
완성된 모델에 추가해서 사용하는 게 좋다.</p>
</div>
</section>
</section>
<section id="id7">
<h2><span class="section-number">11.3. </span>단어 주머니와 단어 임베딩<a class="headerlink" href="#id7" title="Permalink to this heading">#</a></h2>
<p>훈련시키려 하는 자연어 처리 모델에 따라 문장(텍스트)을 변환하는 방식이 달라진다.</p>
<ul class="simple">
<li><p>단어 주머니<font size='2'>bag-of-words</font> 사용 모델</p>
<ul>
<li><p>단어들의 순서를 무시. 문장을 단어들의 집합으로 다룸.</p></li>
<li><p>2015년 이전까지 주로 사용됨.</p></li>
</ul>
</li>
<li><p>시퀀스<font size='2'>sequence</font> 사용 모델</p>
<ul>
<li><p>RNN: 단어들의 순서를 시계열 데이터의 스텝처럼 간주. 2015-2016에 주로 사용됨.</p></li>
<li><p>트랜스포머<font size='2'>Transformer</font> 아키텍처.
기본적으로 순서를 무시하지만 단어 위치를 학습할 수 있는 능력을 가짐.
2017년 이후 많이 활용됨.</p></li>
</ul>
</li>
</ul>
<p>여기서는 IMDB 영화 후기 데이터를 이용하여 두 모델 방식의
활용법과 차이점을 소개한다.</p>
<section id="imdb">
<h3><span class="section-number">11.3.1. </span>IMDB 영화 후기 데이터셋 준비<a class="headerlink" href="#imdb" title="Permalink to this heading">#</a></h3>
<p>IMDB 데이터셋을 직접 다운로드하여 전처리하는 과정을 자세히 살펴본다.</p>
<p><strong>준비 과정 1: 데이터셋 다운로드 압축 풀기</strong></p>
<p><a class="reference external" href="https://ai.stanford.edu/~amaas/data/sentiment/aclImdb_v1.tar.gz">aclIMDB_v1.tar</a> 파일을
다운로드 한 후에 압축을 풀면 아래 구조의 디렉토리가 생성된다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">aclImdb</span><span class="o">/</span>
<span class="o">...</span><span class="n">train</span><span class="o">/</span>
<span class="o">......</span><span class="n">pos</span><span class="o">/</span>
<span class="o">......</span><span class="n">neg</span><span class="o">/</span>
<span class="o">...</span><span class="n">test</span><span class="o">/</span>
<span class="o">......</span><span class="n">pos</span><span class="o">/</span>
<span class="o">......</span><span class="n">neg</span><span class="o">/</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">train</span></code>의 <code class="docutils literal notranslate"><span class="pre">pos</span></code>와 <code class="docutils literal notranslate"><span class="pre">neg</span></code> 서브디렉토리에 각각 12,500 개의 긍정과 부정 후기가
포함되어 있다. <code class="docutils literal notranslate"><span class="pre">aclImdb/train/unsup</span></code> 서브디렉토리는 필요 없기에 삭제한다.</p>
<p><strong>준비 과정 2: 검증셋 준비</strong></p>
<p>훈련셋의 20%를 검증셋으로 떼어낸다.
이를 위해 <code class="docutils literal notranslate"><span class="pre">aclImdb/val</span></code> 디렉토리를 생성한 후에
긍정과 부정 훈련셋 모두 무작위로 섞은 후 그중 20%를 검증셋 디렉토리로 옮긴다.</p>
<p><strong>준비 과정 3: 텐서 데이터셋 준비</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">text_dataset_from_directory()</span></code> 함수를 이용하여
훈련셋, 검증셋, 테스트셋을 준비한다.
자료형은 모두 <code class="docutils literal notranslate"><span class="pre">Dataset</span></code>이며, 배치 크기는 32를 사용한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">batch_size</span> <span class="o">=</span> <span class="mi">32</span>

<span class="n">train_ds</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">text_dataset_from_directory</span><span class="p">(</span>
    <span class="s2">&quot;aclImdb/train&quot;</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span>
    <span class="p">)</span>

<span class="n">val_ds</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">text_dataset_from_directory</span><span class="p">(</span>
    <span class="s2">&quot;aclImdb/val&quot;</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span>
    <span class="p">)</span>

<span class="n">test_ds</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">text_dataset_from_directory</span><span class="p">(</span>
    <span class="s2">&quot;aclImdb/test&quot;</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>각 데이터셋은 배치로 구분되며
배치의 각 입력 데이터 샘플은 텐서플로우의 문자열 자료형인 <code class="docutils literal notranslate"><span class="pre">tf.string</span></code> 텐서이고,
타깃은 0 또는 1의 <code class="docutils literal notranslate"><span class="pre">int32</span></code> 텐서로 지정된다.
0은 부정을, 1은 긍정을 나타낸다.
배치의 크기는 32이다.</p>
<p>예를 들어, 첫째 배치의 입력과 타깃 데이터의 정보는 다음과 같다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">targets</span> <span class="ow">in</span> <span class="n">train_ds</span><span class="p">:</span>
<span class="gp">... </span>    <span class="c1"># 예제: 첫째 배치의 첫째 후기</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;inputs[0]:&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;targets[0]:&quot;</span><span class="p">,</span> <span class="n">targets</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>    
<span class="gp">... </span>    <span class="k">break</span>
<span class="go">inputs[0]: tf.Tensor(b&#39;The film begins with a bunch of kids in reform school and focuses on a kid named \&#39;Gabe\&#39;, who has apparently worked hard to earn his parole. Gabe and his sister move to a new neighborhood to make a fresh start and soon Gabe meets up with the Dead End Kids. The Kids in this film are little punks, but they are much less antisocial than they\&#39;d been in other previous films and down deep, they are well-meaning punks. However, in this neighborhood there are also some criminals who are perpetrating insurance fraud through arson and see Gabe as a convenient scapegoat--after all, he\&#39;d been to reform school and no one would believe he was innocent once he was framed. So, when Gabe is about ready to be sent back to &quot;The Big House&quot;, it\&#39;s up to the rest of the gang to save him and expose the real crooks.&lt;br /&gt;&lt;br /&gt;The &quot;Dead End Kids&quot; appeared in several Warner Brothers films in the late 1930s and the films were generally very good (particularly ANGELS WITH DIRTY FACES). However, after the boys\&#39; contracts expired, they went on to Monogram Studios and the films, to put it charitably, were very weak and formulaic--with Huntz Hall and Leo Gorcey being pretty much the whole show and the group being renamed &quot;The Bowery Boys&quot;. Because ANGELS WASH THEIR FACES had the excellent writing and production values AND Hall and Gorcey were not constantly mugging for the camera, it\&#39;s a pretty good film--and almost earns a score of 7 (it\&#39;s REAL close). In fact, while this isn\&#39;t a great film aesthetically, it\&#39;s sure a lot of fun to watch, so I will give it a 7! Sure, it was a tad hokey-particularly towards the end when the kids take the law into their own hands and Reagan ignores the Bill of Rights--but it was also quite entertaining. The Dead End Kids are doing their best performances and Ronald Reagan and Ann Sheridan provided excellent support. Sure, this part of the film was illogical and impossible but somehow it was still funny and rather charming--so if you can suspend disbelief, it works well.&#39;, shape=(), dtype=string)</span>
<span class="go">targets[0]: tf.Tensor(1, shape=(), dtype=int32)</span>
</pre></div>
</div>
</section>
<section id="id8">
<h3><span class="section-number">11.3.2. </span>단어 주머니 활용법<a class="headerlink" href="#id8" title="Permalink to this heading">#</a></h3>
<p>단어 주머니에 채울 토큰으로 어떤 N-그램을 사용할지 먼저 지정해야 한다.
N-그램의 종류는 다음과 같다.</p>
<ul class="simple">
<li><p>유니그램(unigrams): 하나의 단어가 하나의 토큰</p></li>
<li><p>N-그램(N-grams): 최대 N 개의 이어지는 단어로 이루어진 문구가 하나의 토큰</p></li>
</ul>
<p><strong>방식 1: 유니그램 멀티-핫 인코딩</strong></p>
<p>예를 들어, “the cat sat on the mat” 문장을 유니그램으로 처리하면 다음
단어 주머니가 생성된다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s2">&quot;cat&quot;</span><span class="p">,</span> <span class="s2">&quot;mat&quot;</span><span class="p">,</span> <span class="s2">&quot;on&quot;</span><span class="p">,</span> <span class="s2">&quot;sat&quot;</span><span class="p">,</span> <span class="s2">&quot;the&quot;</span><span class="p">}</span>
</pre></div>
</div>
<p>그런 다음 어휘 색인을 이용하여 생성된 단어 주머니를 멀티-핫 인코딩을 이용하여 1차원 이진 텐서,
즉 0과 1로만 구성된 벡터로 변환한다.</p>
<p>유니그램 멀티-핫 인코딩을 <code class="docutils literal notranslate"><span class="pre">TextVectorization</span></code> 클래스를 이용하면 간단하게 처리할 수 있다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">max_tokens=20000</span></code> 옵션: 빈도가 20,000 등 안에 드는 단어만 멀티-핫 인코딩 적용</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output_mode=&quot;multi_hot&quot;</span></code> 옵션: 유니그램을 멀티-핫 인코딩하기</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">text_vectorization</span> <span class="o">=</span> <span class="n">TextVectorization</span><span class="p">(</span>
    <span class="n">max_tokens</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span>
    <span class="n">output_mode</span><span class="o">=</span><span class="s2">&quot;multi_hot&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>이제 훈련셋의 후기에 포함된 단어들을 이용하여 어휘 색인을 생성한다.
이를 위해 훈련셋에 포함된 후기만 따로 떼어낸다.
이 데이터셋은 이후에도 다른 종류의 어휘 색인을 생성하는 데에 계속 사용된다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 어휘 색인 생성 대상 훈련셋 후기 문장 데이터셋</span>
<span class="n">text_only_train_ds</span> <span class="o">=</span> <span class="n">train_ds</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>이제 <code class="docutils literal notranslate"><span class="pre">adapt()</span></code> 메서드를 이용하여 유니그램 토큰을 멀티-핫 인코딩 하기 위해 필요한 어휘 색인을 생성한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 어휘색인 생성</span>
<span class="n">text_vectorization</span><span class="o">.</span><span class="n">adapt</span><span class="p">(</span><span class="n">text_only_train_ds</span><span class="p">)</span>
</pre></div>
</div>
<p>생성된 어휘 색인을 이용하여 훈련셋, 검증셋, 테스트셋 모두 멀티-핫 인코딩, 즉 벡터화한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">binary_1gram_train_ds</span> <span class="o">=</span> <span class="n">train_ds</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">text_vectorization</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">))</span>
<span class="n">binary_1gram_val_ds</span> <span class="o">=</span> <span class="n">val_ds</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">text_vectorization</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">))</span>
<span class="n">binary_1gram_test_ds</span> <span class="o">=</span> <span class="n">test_ds</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">text_vectorization</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
<p>첫째 배치의 첫째 샘플의 입력과 타깃 데이터는 다음과 같다.
<code class="docutils literal notranslate"><span class="pre">max_tokens=20000</span></code>으로 지정하였기에 모든 문장은 길이가 2만인 멀티-핫 벡터로 변환된다.
예를 들어, n 번 인덱스의 값이 1이면 인덱스에 해당하는 단어가 영화 후기에 사용되었음을 나타낸다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">첫째</span> <span class="n">배치의</span> <span class="n">첫째</span> <span class="n">데이터</span> <span class="n">입력값</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">([</span><span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span> <span class="o">...</span> <span class="mf">0.</span> <span class="mf">0.</span> <span class="mf">0.</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">20000</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float32</span><span class="p">)</span>
<span class="n">첫째</span> <span class="n">배치의</span> <span class="n">첫째</span> <span class="n">데이터</span> <span class="n">타깃</span><span class="p">:</span>   <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
</pre></div>
</div>
<p><em>밀집 모델 활용</em></p>
<p>단어 주머니 형식으로 전처리된 데이터를 이용하는 모델은 기본적으로
밀집 모델을 사용한다.
이유는 단어 주머니에 포함된 토큰들 사이에는 순서가 없기에
모델도 굳이 순서를 고려할 필요가 없기 때문이다.</p>
<p>아래 <code class="docutils literal notranslate"><span class="pre">get_model()</span></code> 함수는 단어 주머니로 전처리된 데이터셋을 이용하는 경우
활용될 매우 단순하며 컴파일된 밀집 모델을 반환한다.
모델의 출력값은 긍정일 확률이며,
최상위 층의 활성화 함수로 <code class="docutils literal notranslate"><span class="pre">sigmoid</span></code>를 사용한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_model</span><span class="p">(</span><span class="n">max_tokens</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="o">=</span><span class="mi">16</span><span class="p">):</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">max_tokens</span><span class="p">,))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="n">hidden_dim</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s2">&quot;relu&quot;</span><span class="p">)(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s2">&quot;sigmoid&quot;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 긍정일 확률 계산</span>
    
    <span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
    
    <span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s2">&quot;rmsprop&quot;</span><span class="p">,</span>
                  <span class="n">loss</span><span class="o">=</span><span class="s2">&quot;binary_crossentropy&quot;</span><span class="p">,</span>
                  <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;accuracy&quot;</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">model</span>
</pre></div>
</div>
<p>밀집 모델 훈련과정은 특별한 게 없다.
훈련 후 테스트셋에 대한 정확도가 89% 보다 조금 낮게 나온다.
최고 성능의 모델이 테스트셋에 대해 95% 정도 정확도를 내는 것보다는 낮지만
무작위로 찍는 모델보다는 훨씬 좋은 모델이다.</p>
<p><strong>방식 2: 바이그램 멀티-핫 인코딩</strong></p>
<p>바이그램(2-grams)을 유니그램 대신 이용해보자.
예를 들어 “the cat sat on the mat” 문장을 바이그램으로 처리하면 다음
단어 주머니가 생성된다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s2">&quot;the&quot;</span><span class="p">,</span> <span class="s2">&quot;the cat&quot;</span><span class="p">,</span> <span class="s2">&quot;cat&quot;</span><span class="p">,</span> <span class="s2">&quot;cat sat&quot;</span><span class="p">,</span> <span class="s2">&quot;sat&quot;</span><span class="p">,</span>
 <span class="s2">&quot;sat on&quot;</span><span class="p">,</span> <span class="s2">&quot;on&quot;</span><span class="p">,</span> <span class="s2">&quot;on the&quot;</span><span class="p">,</span> <span class="s2">&quot;the mat&quot;</span><span class="p">,</span> <span class="s2">&quot;mat&quot;</span><span class="p">}</span>
</pre></div>
</div>
<p>바이그램 멀티-핫 인코딩을 <code class="docutils literal notranslate"><span class="pre">TextVectorization</span></code> 클래스를 이용하면 간단하게 처리할 수 있다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ngrams=2</span></code> 옵션 활용</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">text_vectorization</span> <span class="o">=</span> <span class="n">TextVectorization</span><span class="p">(</span>
    <span class="n">ngrams</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">max_tokens</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span>
    <span class="n">output_mode</span><span class="o">=</span><span class="s2">&quot;multi_hot&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>어휘 색인 생성과 훈련셋, 검증셋, 테스트셋의 벡터화 과정은 동일하다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">text_vectorization</span><span class="o">.</span><span class="n">adapt</span><span class="p">(</span><span class="n">text_only_train_ds</span><span class="p">)</span>

<span class="n">binary_2gram_train_ds</span> <span class="o">=</span> <span class="n">train_ds</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">text_vectorization</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">))</span>
<span class="n">binary_2gram_val_ds</span> <span class="o">=</span> <span class="n">val_ds</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">text_vectorization</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">))</span>
<span class="n">binary_2gram_test_ds</span> <span class="o">=</span> <span class="n">test_ds</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">text_vectorization</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
<p>이전과 동일한 밀집 모델을 훈련시킨 후 테스트셋에 대한 정확도가 90%를 조금 웃돌 정도로 많이 향상되었다.</p>
<p><strong>방식 3: 바이그램 TF-IDF 인코딩</strong></p>
<p>N-그램을 벡터화할 때 사용 빈도를 함께 저장하는 방식을 사용할 수 있다.
단어의 사용 빈도가 아무래도 문장 평가에 중요한 역할을 수행할 것이기 때문이다.
아래 코드에서처럼 <code class="docutils literal notranslate"><span class="pre">output_mode=&quot;count&quot;</span></code> 옵션을 사용하면 된다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">text_vectorization</span> <span class="o">=</span> <span class="n">TextVectorization</span><span class="p">(</span>
    <span class="n">ngrams</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">max_tokens</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span>
    <span class="n">output_mode</span><span class="o">=</span><span class="s2">&quot;count&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>그런데 이렇게 하면 “the”, “a”, “is”, “are” 등의 사용 빈도는 매우 높은 반면에
“Chollet” 등의 단어는 빈도가 거의 0에 가깝게 나온다.
또한 생성된 벡터의 대부분은 0으로 채워질 것이다.
<code class="docutils literal notranslate"><span class="pre">max_tokens=20000</span></code>을 사용한 반면에 하나의 문장엔 많아야 몇 십 개 정도의 단어만 사용되었기 때문이다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">([</span><span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span> <span class="o">...</span> <span class="mf">0.</span> <span class="mf">0.</span> <span class="mf">0.</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">20000</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float32</span><span class="p">)</span>
</pre></div>
</div>
<p>이 점을 고려해서 사용 빈도를 정규화한다.
평균을 원점으로 만들지는 않고 TF-IDF 값으로 나누기만 실행한다.
이유는 평균을 옮기면 벡터의 대부분의 값이 0이 아니게 되어
훈련에 보다 많은 계산이 요구되기 때문이다.</p>
<p><strong>TF-IDF</strong>의 의미는 다음과 같다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">TF</span></code>(Term Frequency)</p>
<ul>
<li><p>하나의 문장에서 사용되는 단어의 빈도</p></li>
<li><p>높을 수록 중요</p></li>
<li><p>예를 들어, 하나의 후기에 “terrible” 이 많이 사용되었다면
해당 후기는 부정일 가능성 높음.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">IDF</span></code>(Inverse Document Frequency)</p>
<ul>
<li><p>데이터셋 전체 문장에서 사용된 단어의 빈도</p></li>
<li><p>낮을 수록 중요.</p></li>
<li><p>“the”, “a”, “is” 등의 <code class="docutils literal notranslate"><span class="pre">IDF</span></code> 값은 높지만 별로 중요하지 않음.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">TF-IDF</span> <span class="pre">=</span> <span class="pre">TF/IDF</span></code></p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">output_mode=&quot;tf_idf&quot;</span></code> 옵션을 사용하면 TF-IDF 인코딩을 지원한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">text_vectorization</span> <span class="o">=</span> <span class="n">TextVectorization</span><span class="p">(</span>
    <span class="n">ngrams</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">max_tokens</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span>
    <span class="n">output_mode</span><span class="o">=</span><span class="s2">&quot;tf_idf&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>어휘색인 생성과 훈련셋, 검증셋, 테스트셋의 벡터화 과정은 동일하다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">text_vectorization</span><span class="o">.</span><span class="n">adapt</span><span class="p">(</span><span class="n">text_only_train_ds</span><span class="p">)</span>

<span class="n">tfidf_2gram_train_ds</span> <span class="o">=</span> <span class="n">train_ds</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">text_vectorization</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">))</span>
<span class="n">tfidf_2gram_val_ds</span> <span class="o">=</span> <span class="n">val_ds</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">text_vectorization</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">))</span>
<span class="n">tfidf_2gram_test_ds</span> <span class="o">=</span> <span class="n">test_ds</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">text_vectorization</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
<p>훈련 후 테스트셋에 대한 정확도가 다시 89% 아래로 내려간다.
여기서는 별 도움이 되지 않았지만 많은 문장 분류 모델에서는 1% 정도의 성능 향상을 가져온다.</p>
<div class="info admonition">
<p class="admonition-title">문자열을 입력받는 모델 실전 배치하기</p>
<p>훈련된 모델을 실전에 배치하려면 문장 벡터화 기능을 전처리 과정에 포함시켜야 한다.
이를 위해 <code class="docutils literal notranslate"><span class="pre">TextVectorization</span></code> 층의 결과를 재활용만 하면 된다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">inputs</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;string&quot;</span><span class="p">)</span>
<span class="c1"># 문장 벡터화 추가</span>
<span class="n">processed_inputs</span> <span class="o">=</span> <span class="n">text_vectorization</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
<span class="c1"># 훈련된 모델에 적용</span>
<span class="n">outputs</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">processed_inputs</span><span class="p">)</span>

<span class="c1"># 최종 모델</span>
<span class="n">inference_model</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
</pre></div>
</div>
<p>이제 위 <code class="docutils literal notranslate"><span class="pre">inference_model</span></code>은 일반 문장을 직접 인자로 받을 수 있다.
예를 들어 “That was an excellent movie, I loved it.”라는 후기는
긍정일 확률이 매우 높다고 예측된다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">raw_text_data</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">([</span>
    <span class="p">[</span><span class="s2">&quot;That was an excellent movie, I loved it.&quot;</span><span class="p">],</span>
<span class="p">])</span>

<span class="n">predictions</span> <span class="o">=</span> <span class="n">inference_model</span><span class="p">(</span><span class="n">raw_text_data</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="id9">
<h3><span class="section-number">11.3.3. </span>시퀀스 활용법<a class="headerlink" href="#id9" title="Permalink to this heading">#</a></h3>
<p>바이그램, 3-그램 등을 이용하여 단어들 사이의 순서 정보를 함께 활용하면 기본적으로 모델의 훈련 성능이 향상된다.
하지만 이와 같은 방식은 일종의 특성 공학<font size='2'>feature engineering</font>이며,
딥러닝은 어떤 형식의 특성 공학도 하지 않는 방향으로 발전해왔다.</p>
<p>여기서는 양방향 LSTM 층으로 구성된 순환 신경망 모델을 훈련시키기 위해
문장에 포함된 단어들의 순서를 있는 그대로 전달하는 방식을 알아 본다.
훈련셋은 IMDB 영화 후기 데이터셋이다.</p>
<p><strong>정수 벡터 데이터셋 준비</strong></p>
<p>먼저 훈련셋의 모든 후기 문장을 정수들의 벡터로 변환한다.
단, 후기 문장이 최대 600 개의 단어만 포함하도록 한다.
또한 사용되는 어휘는 빈도 기준 최대 2만 개로 제한한다.
후기의 길이를 600 개의 단어로 제한한 이유는 후기가 평균적으로 233 개의 단어를 사용하고,
600 단어 이상을 사용하는 후기는 전체의 5% 정도에 불과하기 때문이다.</p>
<p>모든 후기는 최대 600 개의 단어만 포함하도록 하며, 그보다 긴 문장은 잘라서 사용한다.
따라서 생성되는 정수들의 벡터는 모두 길이가 600으로 지정된다.
후기가 600 개보다 적은 수의 단어를 사용한다면 마스크 토큰 0으로 채운다.
벡터에 사용된 정수는 2만보다 작은 값인데,
이는 빈도가 가장 높은 2만 개의 단어만을 대상으로 했기 때문이다.
즉, 사용 빈도가 너무 낮은 단어는 무시한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">max_length</span> <span class="o">=</span> <span class="mi">600</span>
<span class="n">max_tokens</span> <span class="o">=</span> <span class="mi">20000</span>

<span class="n">text_vectorization</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">TextVectorization</span><span class="p">(</span>
    <span class="n">max_tokens</span><span class="o">=</span><span class="n">max_tokens</span><span class="p">,</span>              <span class="c1"># 후기에 사용되는 단어의 종류는 총 2만 종류</span>
    <span class="n">output_mode</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">,</span>
    <span class="n">output_sequence_length</span><span class="o">=</span><span class="n">max_length</span><span class="p">,</span>  <span class="c1"># 하나의 후기에 포함된 최대 단어는 최대 600 개</span>
<span class="p">)</span>

<span class="c1"># 어휘 색인</span>
<span class="n">text_vectorization</span><span class="o">.</span><span class="n">adapt</span><span class="p">(</span><span class="n">text_only_train_ds</span><span class="p">)</span>

<span class="c1"># 후기를 길이가 2만인 정수들의 리스트로 변환</span>
<span class="n">int_train_ds</span> <span class="o">=</span> <span class="n">train_ds</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">text_vectorization</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">))</span>
<span class="n">int_val_ds</span> <span class="o">=</span> <span class="n">val_ds</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">text_vectorization</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">))</span>
<span class="n">int_test_ds</span> <span class="o">=</span> <span class="n">test_ds</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">text_vectorization</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
<p>예를 들어, 변환된 첫째 배치의 첫째 입력 데이터 샘플은 다음과 같다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span>
<span class="p">[</span>   <span class="mi">11</span>     <span class="mi">7</span>     <span class="mi">4</span>  <span class="mi">8614</span>    <span class="mi">18</span>    <span class="mi">38</span>     <span class="mi">9</span>   <span class="mi">139</span>   <span class="mi">138</span>   <span class="mi">197</span>   <span class="mi">640</span>    <span class="mi">12</span>
    <span class="mi">30</span>    <span class="mi">22</span>   <span class="mi">167</span>     <span class="mi">6</span>  <span class="mi">3035</span>     <span class="mi">2</span>    <span class="mi">86</span>  <span class="mi">3146</span>   <span class="mi">664</span>    <span class="mi">19</span>    <span class="mi">12</span>   <span class="mi">291</span>
    <span class="mi">11</span>    <span class="mi">14</span>  <span class="mi">2400</span>  <span class="mi">2996</span>    <span class="mi">13</span>    <span class="mi">55</span>   <span class="mi">322</span>   <span class="mi">429</span>    <span class="mi">11</span>    <span class="mi">19</span>   <span class="mi">172</span>     <span class="mi">4</span>
   <span class="mi">337</span>    <span class="mi">35</span>   <span class="mi">116</span>   <span class="mi">230</span>   <span class="mi">172</span>     <span class="mi">4</span>  <span class="mi">1107</span>     <span class="mi">2</span>   <span class="mi">196</span>  <span class="mi">1562</span>    <span class="mi">14</span>    <span class="mi">12</span>
    <span class="mi">10</span>   <span class="mi">399</span>     <span class="mi">9</span>   <span class="mi">100</span>     <span class="mi">9</span>    <span class="mi">14</span>   <span class="mi">478</span>    <span class="mi">46</span>  <span class="mi">1368</span>   <span class="mi">162</span>    <span class="mi">31</span>    <span class="mi">47</span>
   <span class="mi">509</span>    <span class="mi">56</span>     <span class="mi">2</span>  <span class="mi">7585</span>   <span class="mi">645</span>    <span class="mi">66</span>   <span class="mi">733</span>     <span class="mi">5</span>   <span class="mi">239</span>  <span class="mi">1428</span>     <span class="mi">1</span>    <span class="mi">17</span>
     <span class="mi">2</span>    <span class="mi">86</span>    <span class="mi">18</span>     <span class="mi">3</span>    <span class="mi">56</span>    <span class="mi">47</span>   <span class="mi">645</span>    <span class="mi">12</span>    <span class="mi">23</span>    <span class="mi">66</span>     <span class="mi">6</span>    <span class="mi">28</span>
   <span class="mi">920</span>     <span class="mi">6</span>   <span class="mi">376</span>    <span class="mi">19</span>   <span class="mi">197</span>   <span class="mi">107</span> <span class="mi">14487</span>    <span class="mi">39</span>     <span class="mi">8</span>  <span class="mi">8227</span>    <span class="mi">83</span>    <span class="mi">23</span>
   <span class="mi">103</span>   <span class="mi">235</span>     <span class="mi">1</span>    <span class="mi">16</span>  <span class="mi">6307</span>    <span class="mi">13</span>     <span class="mi">4</span>   <span class="mi">309</span>   <span class="mi">869</span>    <span class="mi">21</span>     <span class="mi">2</span>  <span class="mi">7585</span>
   <span class="mi">645</span>    <span class="mi">10</span>    <span class="mi">14</span>   <span class="mi">776</span>     <span class="mi">6</span>   <span class="mi">158</span>    <span class="mi">12</span>   <span class="mi">593</span>     <span class="mi">5</span>     <span class="mi">2</span>   <span class="mi">645</span>    <span class="mi">67</span>
    <span class="mi">41</span>  <span class="mi">3488</span>  <span class="mi">5321</span>     <span class="mi">8</span>   <span class="mi">188</span>    <span class="mi">48</span>    <span class="mi">67</span>   <span class="mi">208</span>    <span class="mi">57</span>     <span class="mi">1</span>    <span class="mi">31</span>    <span class="mi">32</span>
     <span class="mi">2</span>  <span class="mi">1990</span>    <span class="mi">67</span>   <span class="mi">154</span>   <span class="mi">239</span>  <span class="mi">1265</span>    <span class="mi">35</span>   <span class="mi">154</span>    <span class="mi">66</span>     <span class="mi">4</span>     <span class="mi">1</span>     <span class="mi">3</span>
    <span class="mi">67</span>   <span class="mi">208</span>     <span class="mi">8</span>    <span class="mi">50</span>  <span class="mi">1244</span>   <span class="mi">450</span>    <span class="mi">39</span>    <span class="mi">55</span>   <span class="mi">322</span>     <span class="mi">6</span>   <span class="mi">103</span>    <span class="mi">12</span>
   <span class="mi">217</span>    <span class="mi">53</span>     <span class="mi">6</span>   <span class="mi">493</span>    <span class="mi">72</span>   <span class="mi">167</span>     <span class="mi">6</span>     <span class="mi">2</span>  <span class="mi">3925</span>     <span class="mi">3</span>    <span class="mi">11</span>    <span class="mi">18</span>
     <span class="mi">7</span>   <span class="mi">479</span>     <span class="mi">8</span>   <span class="mi">144</span>     <span class="mi">1</span>    <span class="mi">13</span>  <span class="mi">8499</span>    <span class="mi">49</span>   <span class="mi">330</span>     <span class="mi">2</span>   <span class="mi">223</span>    <span class="mi">14</span>
  <span class="mi">5673</span>    <span class="mi">22</span>   <span class="mi">730</span>    <span class="mi">15</span>  <span class="mi">1428</span>    <span class="mi">15</span>     <span class="mi">8</span>     <span class="mi">2</span>    <span class="mi">86</span>    <span class="mi">42</span>   <span class="mi">327</span>    <span class="mi">18</span>
    <span class="mi">19</span>   <span class="mi">943</span>     <span class="mi">5</span>   <span class="mi">250</span>    <span class="mi">16</span>     <span class="mi">2</span>   <span class="mi">322</span>    <span class="mi">57</span>  <span class="mi">2027</span>  <span class="mi">1932</span>   <span class="mi">383</span>    <span class="mi">62</span>
    <span class="mi">14</span>     <span class="mi">4</span> <span class="mi">13077</span>    <span class="mi">16</span>    <span class="mi">70</span>     <span class="mi">4</span>   <span class="mi">110</span>   <span class="mi">215</span>    <span class="mi">19</span>   <span class="mi">157</span>   <span class="mi">100</span>   <span class="mi">609</span>
     <span class="mi">2</span>  <span class="mi">1013</span>     <span class="mi">5</span>     <span class="mi">1</span>   <span class="mi">500</span>    <span class="mi">55</span>   <span class="mi">322</span>  <span class="mi">3987</span>    <span class="mi">22</span>   <span class="mi">242</span>     <span class="mi">4</span>  <span class="mi">3852</span>
   <span class="mi">690</span>    <span class="mi">14</span>  <span class="mi">2207</span>    <span class="mi">16</span>    <span class="mi">12</span>  <span class="mi">2227</span>    <span class="mi">13</span>    <span class="mi">32</span>     <span class="mi">8</span>    <span class="mi">32</span>   <span class="mi">450</span>   <span class="mi">129</span>
    <span class="mi">11</span>     <span class="mi">7</span>     <span class="mi">4</span>    <span class="mi">84</span>    <span class="mi">18</span>    <span class="mi">16</span>   <span class="mi">322</span>     <span class="mi">5</span>    <span class="mi">98</span>   <span class="mi">588</span>    <span class="mi">29</span>   <span class="mi">172</span>
  <span class="mi">1319</span>  <span class="mi">2224</span>     <span class="mi">6</span>   <span class="mi">381</span>    <span class="mi">99</span>   <span class="mi">104</span>    <span class="mi">10</span>   <span class="mi">328</span>    <span class="mi">22</span>     <span class="mi">6</span>    <span class="mi">28</span>  <span class="mi">2012</span>
  <span class="mi">2677</span>    <span class="mi">19</span>   <span class="mi">193</span>    <span class="mi">66</span>     <span class="mi">6</span>  <span class="mi">1810</span>    <span class="mi">58</span>     <span class="mi">3</span>   <span class="mi">460</span>   <span class="mi">127</span>     <span class="mi">2</span>   <span class="mi">247</span>
   <span class="mi">301</span>     <span class="mi">4</span>   <span class="mi">163</span>    <span class="mi">93</span>    <span class="mi">12</span>    <span class="mi">67</span>   <span class="mi">324</span>     <span class="mi">1</span>    <span class="mi">72</span>   <span class="mi">848</span>    <span class="mi">19</span>   <span class="mi">321</span>
  <span class="mi">2224</span>     <span class="mi">6</span>   <span class="mi">544</span>     <span class="mi">2</span>   <span class="mi">698</span>   <span class="mi">301</span>    <span class="mi">11</span>    <span class="mi">29</span>   <span class="mi">450</span>   <span class="mi">129</span>  <span class="mi">1245</span>   <span class="mi">183</span>
   <span class="mi">574</span>   <span class="mi">149</span>    <span class="mi">23</span>   <span class="mi">225</span>   <span class="mi">158</span>    <span class="mi">12</span>    <span class="mi">23</span>   <span class="mi">341</span>     <span class="mi">9</span>   <span class="mi">100</span>     <span class="mi">0</span>     <span class="mi">0</span>
     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">600</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int64</span><span class="p">)</span>
</pre></div>
</div>
<section id="id10">
<h4><span class="section-number">11.3.3.1. </span>원-핫 단어 벡터<a class="headerlink" href="#id10" title="Permalink to this heading">#</a></h4>
<p>정수 벡터를 순차 모델의 입력값으로 그대로 사용할 수는 없다.
대신 정수 벡터에 포함된 각각의 정수에 원-핫 인코딩을 적용하면
원-핫 벡터로 이루어진 시퀀스가 생성되고 이를 순환 신경망 모델의 입력값으로 사용한다.</p>
<div class="proof example admonition" id="exp-one-hot-sequence">
<p class="admonition-title"><span class="caption-number">Example 11.2 </span> (<code class="docutils literal notranslate"><span class="pre">tf.one_hot()</span></code> 함수)</p>
<section class="example-content" id="proof-content">
<p>정수 벡터 <code class="docutils literal notranslate"><span class="pre">[2,</span> <span class="pre">1,</span> <span class="pre">4,</span> <span class="pre">0,</span> <span class="pre">0]</span></code>의 각 항목에 원-핫 인코딩을 적용하여
생성되는 원-핫 벡터로 이루어진 시퀀스가 생성된다.
단, 벡터에 사용된 정수는 0에서 4까지라고 가정한다.</p>
<p>따라서 원-핫 벡터 하나의 길이는 5가 되며,
<code class="docutils literal notranslate"><span class="pre">[2,</span> <span class="pre">1,</span> <span class="pre">4,</span> <span class="pre">0,</span> <span class="pre">0]</span></code>의 각 항목을 원-핫 벡터로 변환한 값들로 이뤄진 시퀀스는 다음과 같으며,
<code class="docutils literal notranslate"><span class="pre">tf.one_hot()</span></code> 함수를 이용하면 된다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tf</span><span class="o">.</span><span class="n">one_hot</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">depth</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">[[0, 0, 1, 0, 0],      # 2</span>
<span class="go"> [0, 1, 0, 0, 0],      # 1</span>
<span class="go"> [0, 0, 0, 0, 1],      # 4</span>
<span class="go"> [1, 0, 0, 0, 0],      # 0</span>
<span class="go"> [1, 0, 0, 0, 0]]      # 0</span>
</pre></div>
</div>
</section>
</div><p>아래 코드는 <code class="docutils literal notranslate"><span class="pre">tf.one_hot()</span></code> 함수를 전처리로 활용하는 순환 신경망 모델을 정의한다.
이렇게 하면 정수 벡터를 바로 모델의 입력값으로 사용할 수 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">inputs</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
<span class="c1"># 원-핫 인코딩</span>
<span class="n">embedded</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">one_hot</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">max_tokens</span><span class="p">)</span>  <span class="c1"># (600, 20000) 모양의 출력값 생성</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Bidirectional</span><span class="p">(</span><span class="n">layers</span><span class="o">.</span><span class="n">LSTM</span><span class="p">(</span><span class="mi">32</span><span class="p">))(</span><span class="n">embedded</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
<span class="n">outputs</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s2">&quot;sigmoid&quot;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
</pre></div>
</div>
<p>그런데 위 모델의 훈련 과정이 매우 느리다.
이유는 입력 데이터가 너무 많은 특성을 갖기 때문이다.
입력 데이터 하나, 하나의 문장을 변환시킨 원-핫 단어 벡터의 모양은 <code class="docutils literal notranslate"><span class="pre">(600,</span> <span class="pre">20000)</span></code>인 2차원 텐서이다.
따라서 총 <code class="docutils literal notranslate"><span class="pre">600</span> <span class="pre">*</span> <span class="pre">20,000</span> <span class="pre">=</span> <span class="pre">12,000,000</span></code> 개의 항목이 포함되어 있고 그만큼의
가중치가 훈련되어야 한다.
이에 더해 양방향 LSTM은 엄청난 양의 반복을 실행하기에 그만큼 훈련 시간이 길어질 수밖에 없다.</p>
<p>게다가 훈련된 모델의 성능이 별로 좋지 않다.
테스트셋에 대한 정확도가 87% 정도에 불과해서 바이그램 모델보다 성능이 낮다.</p>
</section>
<section id="id11">
<h4><span class="section-number">11.3.3.2. </span>단어 임베딩<a class="headerlink" href="#id11" title="Permalink to this heading">#</a></h4>
<p>앞서 보았듯이 정수 벡터를 원-핫 인코딩해서 원-핫 워드 벡터로 구성된 시퀀스를 생성하는 방식은 별로 적절하지 않다.
변환된 벡터의 특성이 너무 많으며, 단어들 사이의 다음과 같은 유기적 관계도 제대로 반영되지 못한다.</p>
<ul class="simple">
<li><p>“movie”와 “film”, “비디오”와 “동영상”, “강아지”와 “개” 등이 사실상 동일하다는 동의어 관계</p></li>
<li><p>“왕”(남자)과 “여왕”(여자), “boy”와 “girl” 등의 성별 관계</p></li>
<li><p>“king”의 복수는 “kings” 등 문법 규칙 관계</p></li>
<li><p>“고양이”와 “호랑이”는 고양이과, “개”와 “늑대”는 개과, “고양이”와 “개”는 애완동물, “늑대”와 “호랑이”는 야생동물 등의 생물 분류 관계</p></li>
</ul>
<p>반면에 <strong>단어 임베딩</strong><font size='2'>word embedding</font>은
단어들 사이의 유기적 관계를 모델 스스로 학습을 통해 찾도록 유도하며,
보통 다음 두 가지 방식으로 활용된다.</p>
<ul class="simple">
<li><p>모델 훈련과 단어 임베딩 학습 동시 진행:
언어 종류와 모델 훈련 목적에 따라 기본적으로 서로 다른 단어 사이의 관계가 학습되어야 한다.
예를 들어, 영화 후기 감성 분석과 재판 판결문 분석은 서로 다른 단어 임베딩을 사용할 수밖에 없다.</p></li>
<li><p>기존에 잘 훈련된 워드 임베딩 활용:
합성곱 신경망에서 이미지넷 등의 대용량 데이터셋을 활용하여 잘 훈련된 모델을 재활용하는 것처럼
잘 구성된 대용량의 어휘 색인을 이용하여 생성된 단어 임베딩을 활용한다.</p></li>
</ul>
<p>먼저 케라스의 <code class="docutils literal notranslate"><span class="pre">Embedding</span></code> 층을 모델에 추가하여 단어 임베딩 학습을
모델 훈련과 함께 진행하는 방식을 살펴본다.</p>
<p><strong>케라스의 <code class="docutils literal notranslate"><span class="pre">Embedding</span></code> 층 활용</strong></p>
<p>케라스의 <code class="docutils literal notranslate"><span class="pre">Embedding</span></code> 층은 하나의 문장이 입력되면
문장에 포함된 단어들 사이에 존재하는 연관성을
어휘 색인을 참고하여 문장에 포함된 각각의 단어를 벡터로 변환시켜서 구성한
시퀀스를 생성한다.
단어를 변환해서 생성된 단어 벡터는 부동소수점으로 구성된다.
단어 벡터의 길이는 보통 256, 512, 1024 등으로 정한다.
이는 모델로 하여금 한 단어에 대해 256 개, 512 개, 또는 1024 개 등 지정된 개수만큼의
단어 특성을 찾도록 유도한다.</p>
<p>아래 그림은 원-핫 인코딩 방식과 단어 임베딩 방식의 차이점을 보여준다.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head text-left"><p>원-핫 단어 벡터</p></th>
<th class="head text-left"><p>단어 임베딩</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-left"><p>희소 벡터</p></td>
<td class="text-left"><p>밀집 벡터</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p>매우 많은 특성</p></td>
<td class="text-left"><p>적절한 양의 특성</p></td>
</tr>
<tr class="row-even"><td class="text-left"><p>직접 전처리</p></td>
<td class="text-left"><p>모델 스스로 훈련</p></td>
</tr>
</tbody>
</table>
<div align="center"><img src="https://drek4537l1klr.cloudfront.net/chollet2/Figures/11-02.png" style="width:60%;"></div>
<p><div style="text-align: center">&lt;그림 출처: <a href="https://www.manning.com/books/deep-learning-with-python-second-edition">Deep Learning with Python(2판)</a>&gt;</div></p><p>예를 들어, 600 개의 단어로 이루어진 문장이 주어졌을 때,
문장에 포함된 각 단어에 대해 다른 단어들과의 연관성을 256 개 찾아낸다.
그런 다음 길이가 256인 600개의 벡터로 이루어진 시퀀스,
즉 <code class="docutils literal notranslate"><span class="pre">(600,</span> <span class="pre">256)</span></code> 모양의 시퀀스를 생성한다.</p>
<p>그런데 후기 문장의 길이가 600이 되지 않는 경우 나머지는
<strong>패딩</strong><font size='2'>padding</font>에 의해 0으로 채워진다.
하지만 이렇게 의미 없이 추가된 0이 훈련에 좋지 않은 영향을 미친다.
따라서 모델이 패딩으로 사용된 0이 있다는 사실을 인지하도록 도와주는
<strong>마스킹</strong><font size='2'>masking</font> 기능을 활용하면 보다 좋은 성능을 얻을 수 있다.</p>
<p>방금 설명한 것을 아래 <code class="docutils literal notranslate"><span class="pre">Embedding</span></code> 층이 실행한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">layers</span><span class="o">.</span><span class="n">Embedding</span><span class="p">(</span><span class="n">input_dim</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span> <span class="n">output_dim</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">mask_zero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="warning admonition">
<p class="admonition-title"><code class="docutils literal notranslate"><span class="pre">Embedding</span></code> 층과 <code class="docutils literal notranslate"><span class="pre">mask_zero</span></code> 옵션</p>
<p>입력 벡터에 사용되는 0이 특별한 의미를 갖는 경우 <code class="docutils literal notranslate"><span class="pre">mask_zero</span></code> 옵션을 기본값인 <code class="docutils literal notranslate"><span class="pre">False</span></code>로 지정해야 한다.
<code class="docutils literal notranslate"><span class="pre">mask_zero=True</span></code>는 입력 벡터의 길이가 달라 0을 패딩으로 사용해야 하는 경우에만 사용한다.</p>
</div>
<p>아래 코드는 양방향 LSTM을 사용하는 순환 신경망 모델에
마스킹을 활용 단어 임베딩 방식을 적용하는 것을 보여준다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">inputs</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
<span class="c1"># 마스킹 활용 단어 임베딩</span>
<span class="n">embedded</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Embedding</span><span class="p">(</span>
    <span class="n">input_dim</span><span class="o">=</span><span class="n">max_tokens</span><span class="p">,</span> <span class="n">output_dim</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">mask_zero</span><span class="o">=</span><span class="kc">True</span><span class="p">)(</span><span class="n">inputs</span><span class="p">)</span>
<span class="c1"># 양방향 LSTM</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Bidirectional</span><span class="p">(</span><span class="n">layers</span><span class="o">.</span><span class="n">LSTM</span><span class="p">(</span><span class="mi">32</span><span class="p">))(</span><span class="n">embedded</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
<span class="n">outputs</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s2">&quot;sigmoid&quot;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Embedding</span></code> 층을 통과하면 후기 문장에 사용된 600개 단어 각각이 총 256개의 특성으로 구성된
벡터로 변환되었음을 <code class="docutils literal notranslate"><span class="pre">summary()</span></code> 를 통해 확인할 수 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
<span class="go">_________________________________________________________________</span>
<span class="go"> Layer (type)                Output Shape              Param #   </span>
<span class="go">=================================================================</span>
<span class="go"> input_7 (InputLayer)        [(None, 600)]            0         </span>
<span class="go">                                                                 </span>
<span class="go"> embedding_1 (Embedding)     (None, 600, 256)         5120000   </span>
<span class="go">                                                                 </span>
<span class="go"> bidirectional_2 (Bidirectio  (None, 64)               73984     </span>
<span class="go"> nal)                                                            </span>
<span class="go">                                                                 </span>
<span class="go"> dropout_5 (Dropout)         (None, 64)                0         </span>
<span class="go">                                                                 </span>
<span class="go"> dense_8 (Dense)             (None, 1)                 65        </span>
<span class="go">                                                                 </span>
<span class="go">=================================================================</span>
<span class="go">Total params: 5,194,049</span>
<span class="go">Trainable params: 5,194,049</span>
<span class="go">Non-trainable params: 0</span>
</pre></div>
</div>
<p>모델의 훈련은 원-핫 인코딩 방식보다 훨씬 빠르게 이루어지며 성능은 88% 정도로 살짝 향상된다.
바이그램 모델보다 성능이 여전히 떨어지는 이유 중에 하나는 후기에 사용된 단어의 수를 600 개로 제한하였기 때문이다.</p>
</section>
<section id="glove">
<h4><span class="section-number">11.3.3.3. </span>GloVe 단어 임베딩<a class="headerlink" href="#glove" title="Permalink to this heading">#</a></h4>
<p>합성곱 신경망에서 이미지넷<font size='2'>ImageNet</font> 데이터셋을 이용하여
잘 훈련된 모델을 재활용했던 것처럼 대량의 문장을 분석하여 훈련된 단어 임베딩을 활용할 수 있다.</p>
<p>여기서는 2014년에 스탠포드 대학교의 연구자들이 위키피디아에 사용된 수 많은 문장을 분석하여 생성한
<a class="reference external" href="https://nlp.stanford.edu/projects/glove/">GloVe(Gloval Vectors for Word Representation)</a>
어휘 색인을 활용한다.</p>
<p><strong>임베딩 파일 다운로드</strong></p>
<p><a class="reference external" href="http://nlp.stanford.edu/data/glove.6B.zip">glove.6B.zip</a> 파일을 다운로드한다.
압축파일의 크기는 822 MB이다.
다운로드한 파일의 압축을 풀면 다음 세 개의 파일이 생성된다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">glove.6B.50d.txt</span></code> (약 160 MB)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">glove.6B.100d.txt</span></code> (약 330 MB)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">glove.6B.200d.txt</span></code> (약 670 MB)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">glove.6B.300d.txt</span></code> (약 1 GB)</p></li>
</ul>
<p>예를 들어 <code class="docutils literal notranslate"><span class="pre">glove.6B.100d.txt</span></code> 파일의 첫 20줄은 다음과 같다.
단어별로 하나의 단어가 가질 수 있는 100개의 특성이 부동소수점으로 지정되어 있지만
화면상 10여 개의 값만 보여지고 나머지는 화면에서 잘렸다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/dlp2/master/jupyter-book/imgs/ch11-glove01.jpg" style="width:80%;"></div><p><strong>임베딩 층 지정</strong></p>
<p>총 40만 개의 단어 정보를 포함한 <code class="docutils literal notranslate"><span class="pre">glove.6B.100d.txt</span></code> 파일을 이용하여 단어 임베딩을 실행하려면
임베딩 층을 다음과 같이 설정한다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">max_tokens</span> <span class="pre">=</span> <span class="pre">20000</span></code>: 빈도가 2만등 안에 드는 단어만 대상으로 함.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">embedding_dim</span> <span class="pre">=</span> <span class="pre">100</span></code>: 단어별로 총 100개의 특성을 갖는 벡터가 연결된다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">embedding_matrix</span></code>: <code class="docutils literal notranslate"><span class="pre">glove.6B.100d.txt</span></code> 파일에 포함된 어휘 토큰 중에서
훈련셋에 포함된 2만개의 단어에 해당하는 어휘만 추출해서 생성한
<code class="docutils literal notranslate"><span class="pre">(20000,</span> <span class="pre">100)</span></code> 모양의 임베딩 행렬이다.
이 행렬을 어휘 색인으로 참고하여 후기에 사용된 각 단어에 대해 하나의 단어 벡터를 연결한다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Constant</span></code>: 단어 임베딩의 기준으로 사용될 행렬을 상수 텐서로 지정한다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">trainable=False</span></code>: 단어 임베딩의 기준이 되는 임베딩 행렬이 훈련되지 않도록 한다.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">embedding_layer</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Embedding</span><span class="p">(</span>
    <span class="n">max_tokens</span><span class="p">,</span>
    <span class="n">embedding_dim</span><span class="p">,</span>
    <span class="n">embeddings_initializer</span><span class="o">=</span><span class="n">keras</span><span class="o">.</span><span class="n">initializers</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">embedding_matrix</span><span class="p">),</span>
    <span class="n">trainable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">mask_zero</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p><strong>모델 지정 및 훈련</strong></p>
<p>모델 구성은 임베딩 층만 제외하고 이전과 동일하다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">inputs</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
<span class="c1"># GloVe 단어 임베딩 활용</span>
<span class="n">embedded</span> <span class="o">=</span> <span class="n">embedding_layer</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Bidirectional</span><span class="p">(</span><span class="n">layers</span><span class="o">.</span><span class="n">LSTM</span><span class="p">(</span><span class="mi">32</span><span class="p">))(</span><span class="n">embedded</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
<span class="n">outputs</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s2">&quot;sigmoid&quot;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Embedding</span></code> 층을 통과하면 후기 문장에 사용된 600개 단어 각각이 총 100개의 특성으로 구성된
벡터로 변환되었음을 <code class="docutils literal notranslate"><span class="pre">summary()</span></code> 를 통해 확인할 수 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
<span class="go">_________________________________________________________________</span>
<span class="go"> Layer (type)                Output Shape              Param #   </span>
<span class="go">=================================================================</span>
<span class="go"> input_8 (InputLayer)        [(None, 600)]            0         </span>
<span class="go">                                                                 </span>
<span class="go"> embedding_2 (Embedding)     (None, 600, 100)         2000000   </span>
<span class="go">                                                                 </span>
<span class="go"> bidirectional_3 (Bidirectio  (None, 64)               34048     </span>
<span class="go"> nal)                                                            </span>
<span class="go">                                                                 </span>
<span class="go"> dropout_6 (Dropout)         (None, 64)                0         </span>
<span class="go">                                                                 </span>
<span class="go"> dense_9 (Dense)             (None, 1)                 65        </span>
<span class="go">                                                                 </span>
<span class="go">=================================================================</span>
<span class="go">Total params: 2,034,113</span>
<span class="go">Trainable params: 34,113</span>
<span class="go">Non-trainable params: 2,000,000</span>
<span class="go">_________________________________________________________________</span>
</pre></div>
</div>
<p>훈련 결과가 특별히 나아지지는 않는다. 이유는 훈련 데이터셋이 충분히 크기에 굳이 외부 임베딩 파일을
이용하지 않아도 자체적으로 단어들 사이의 관계를 잘 찾기 때문이다.
하지만 훈련셋이 더 작은 경우 잘 훈련된 임베딩 파일을 이용하면 보다 효율적으로 훈련이 진행된다.</p>
<h1>2부</h1><p>트랜스포머 아키텍처와 시퀀스-투-시퀀스 학습을 알아본다.</p>
</section>
</section>
</section>
<section id="id12">
<h2><span class="section-number">11.4. </span>트랜스포머 아키텍처<a class="headerlink" href="#id12" title="Permalink to this heading">#</a></h2>
<p>2017년 논문 <a class="reference external" href="https://arxiv.org/abs/1706.03762">“Attention is all you need”</a>에서
소개된 <strong>트랜스포머</strong><font size='2'>Transformer</font> 아키텍처는 자연어처리 분야에서 혁명을 불러왔다.
트랜스포머는 “<strong>뉴럴 어텐션</strong><font size='2'>Neural Attention</font>” 기법을 이용하여
순환층과는 다르게 작동하는 순차 모델<font size='2'>sequence model</font>을 지원한다.</p>
<p>여기서는 뉴럴 어텐션의 작동법을 설명한 후에 트랜스포머 인코더를 이용하여 IMDB 영화 후기 분류 모델을 구현한다.</p>
<section id="id13">
<h3><span class="section-number">11.4.1. </span>셀프 어텐션<a class="headerlink" href="#id13" title="Permalink to this heading">#</a></h3>
<p>입력값의 특성 중에 보다 중요한 특성에 <strong>집중</strong><font size='2'>attention</font>하면 보다 효율적으로
훈련이 진행될 수 있다.</p>
<p><strong>집중의 중요성</strong></p>
<p>아래 그림에서 볼 수 있듯이 이미지의 주요 부분에 집중하여 보다 효율적인 이미지 분석을 진행할 수 있다.</p>
<div align="center"><img src="https://drek4537l1klr.cloudfront.net/chollet2/Figures/11-05.png" style="width:70%;"></div>
<p><div style="text-align: center">&lt;그림 출처: <a href="https://www.manning.com/books/deep-learning-with-python-second-edition">Deep Learning with Python(2판)</a>&gt;</div></p><p><strong>유사 아이디어</strong></p>
<p>앞서 유사한 아이디어를 활용한 적이 있다.</p>
<ul class="simple">
<li><p>합성곱 신경망의 맥스 풀링<font size='2'>max pooling</font>: 지역적으로 가장 중요한 특성만 사용한다.</p></li>
<li><p>TF-IDF 정규화: 텍스트 벡터화를 위해 사용되는 TF-IDF 정규화는
사용되는 토큰에 포함된 정보의 중요도를 평가하여 보다 중요한 정보를 담은 토큰에 집중한다.</p></li>
</ul>
<p><strong>자연어 처리에서의 셀프 어텐션</strong></p>
<p>자연어 처리에서의 <strong>셀프 어텐션</strong><font size='2'>self-attention</font> 기법은
문장을 시퀀스로 변환 할 때
주어진 문장에 사용된 단어들 사이의 연관성, 즉 <strong>문맥</strong><font size='2'>context</font>을 파악하여
활용한다.</p>
<p>아래 그림은 “The train  left the station on time.” 이라는 문장에
셀프 어텐션을 적용하여 입력 문장을 하나의 시퀀스로 변환하는 과정을 보여준다.</p>
<ul class="simple">
<li><p>문장을 <code class="docutils literal notranslate"><span class="pre">Embedding</span></code> 층을 이용하여 단어 임베딩시킨다.</p></li>
<li><p>생성된 벡터 시퀀스에 셀프 어텐션을 적용하여 문맥이 적용된 동일 모양의 새로운 벡터 시퀀스를 생성한다.</p>
<ul>
<li><p>1단계: 문장에 사용된 각 토큰들 사이의 연관성을 계산하여 어텐션 점수<font size='2'>attention scores</font> 생성.</p></li>
<li><p>2단계: 계산된 어텐션 점수를 시퀀스의 각 단어 벡터와 결합시켜서 한 단어를 기준으로 다른 단어들이 갖는 의미를 반영한 단어 벡터들의 시퀀스 생성.</p></li>
</ul>
</li>
</ul>
<p>아래 그림에서는 “station” 단어에 해당하는 벡터가 새로운 벡터로 변환되는 과정을 보여준다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/dlp2/master/jupyter-book/imgs/ch11-self_attention.jpg" style="width:100%;"></div>
<p><div style="text-align: center">&lt;그림 출처: <a href="https://www.manning.com/books/deep-learning-with-python-second-edition">Deep Learning with Python(2판)</a>&gt;</div></p><p>아래 <code class="docutils literal notranslate"><span class="pre">self_attention()</span></code> 함수가 셀프 어텐션이 작동하는 과정을 잘 보여준다.
함수의 입력값으로 단어 임베딩된 시퀀스를 사용한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">self_attention</span><span class="p">(</span><span class="n">input_sequence</span><span class="p">):</span>
    <span class="c1"># 변환된 시퀀스 저장용</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">input_sequence</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    
    <span class="c1"># 단어 임베딩된 시퀀스의 단어 벡터 각각에 대해 셀프 어텐션 실행. 위 그림 참고.</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pivot_vector</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">input_sequence</span><span class="p">):</span>

        <span class="c1"># 주어진 단어 벡터 pivot_vector와 다른 단어 벡터들 사이의 문맥 점수 계산</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_sequence</span><span class="p">),))</span>
        <span class="c1"># 계산된 점수를 스케일링 후 소프트맥스 적용</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">vector</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">input_sequence</span><span class="p">):</span>
            <span class="n">scores</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pivot_vector</span><span class="p">,</span> <span class="n">vector</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">scores</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">input_sequence</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">softmax</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>

        <span class="c1"># 문맥이 반영된 단어 벡터로 변환: 각 단어 벡터와 점수를 곱한 결과를 더함.</span>
        <span class="n">new_pivot_representation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">pivot_vector</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">vector</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">input_sequence</span><span class="p">):</span>
            <span class="n">new_pivot_representation</span> <span class="o">+=</span> <span class="n">vector</span> <span class="o">*</span> <span class="n">scores</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        
        <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pivot_representation</span>
    <span class="k">return</span> <span class="n">output</span>
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">MultiHeadAttention</span></code> 층 활용</strong></p>
<p>케라스의 <code class="docutils literal notranslate"><span class="pre">MultiHeadAttention</span></code> 층이 <code class="docutils literal notranslate"><span class="pre">self_attention()</span></code> 함수의 셀프 어텐션 기능을
포함한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">num_heads</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># 두 개의 셀프 어텐션을 동시에 진행. 각각 다른 문맥을 파악하도록 유도.</span>
<span class="n">embed_dim</span> <span class="o">=</span> <span class="mi">256</span> 

<span class="n">mha_layer</span> <span class="o">=</span> <span class="n">MultiHeadAttention</span><span class="p">(</span><span class="n">num_heads</span><span class="o">=</span><span class="n">num_heads</span><span class="p">,</span> <span class="n">key_dim</span><span class="o">=</span><span class="n">embed_dim</span><span class="p">)</span>
<span class="n">outputs</span> <span class="o">=</span> <span class="n">mha_layer</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span>
</pre></div>
</div>
<div class="info admonition">
<p class="admonition-title">질문-열쇠-값</p>
<p>동일한 값을 인자로 세 번 사용하는 <code class="docutils literal notranslate"><span class="pre">mha_layer(inputs,</span> <span class="pre">inputs,</span> <span class="pre">inputs)</span></code>, 즉 셀프 어텐션의 작동 과정을
식으로 표현하면 다음과 같다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">outputs</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">inputs</span> <span class="o">*</span> <span class="n">pairwise_scores</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">inputs</span><span class="p">))</span>
</pre></div>
</div>
<p>위 식은 원래 검색 엔진 또는 추천 시스템 등에서
질문-열쇠-값<font size='2'>query-key-value</font>
세 개의 입력값을 받는 보다 일반화된 어텐션의 작동과정을 표현한 식의 특별한 경우이다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">outputs</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">values</span> <span class="o">*</span> <span class="n">pairwise_scores</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">keys</span><span class="p">))</span>
</pre></div>
</div>
<p>예를 들어, 아래 그림은 “dogs on the beach.”라는 <strong>질문</strong><font size='2'>query</font>에 가장
적절한 사진을 검색한다면 각 사진과의 <strong>핵심 연관성</strong><font size='2'>key</font> 점수를
<strong>해당 사진</strong><font size='2'>value</font>과 결합하여 가장 높은 점수를 갖는 사진을
추천하는 것을 보여준다.</p>
<div align="center"><img src="https://drek4537l1klr.cloudfront.net/chollet2/Figures/11-07.png" style="width:80%;"></div>
<p><div style="text-align: center">&lt;그림 출처: <a href="https://www.manning.com/books/deep-learning-with-python-second-edition">Deep Learning with Python(2판)</a>&gt;</div></p>
</div>
</section>
<section id="id14">
<h3><span class="section-number">11.4.2. </span>멀티헤드 어텐션<a class="headerlink" href="#id14" title="Permalink to this heading">#</a></h3>
<p>어텐션 변환을 수행하는 <strong>헤드</strong><font size='2'>head</font>를 여러 개 사용해서
다양한 관점에서 단어들 사이의 연관성을 알아낸 후에 알아낸 결과를 합치는 기법이
<strong>멀티헤드 어텐션</strong><font size='2'>multi-head attention</font>이다.
아래 그림은 두 개의 헤드가 작동하는 과정을 보여준다.</p>
<p>각각의 헤드에 별도의 밀집층이 사용됨에 주목한다.
질문, 열쇠, 값을 어텐션에 넣어 주기 전에 먼저 밀집층을 이용하여
모델 스스로 질문, 열쇠, 값을 적절하게 변환하도록 유도한다.</p>
<div align="center"><img src="https://drek4537l1klr.cloudfront.net/chollet2/Figures/11-08.png" style="width:70%;"></div>
<p><div style="text-align: center">&lt;그림 출처: <a href="https://www.manning.com/books/deep-learning-with-python-second-edition">Deep Learning with Python(2판)</a>&gt;</div></p></section>
<section id="id15">
<h3><span class="section-number">11.4.3. </span>트랜스포머 인코더<a class="headerlink" href="#id15" title="Permalink to this heading">#</a></h3>
<p>헤드에 사용된 밀집층의 역할이 중요하며 크다는 사실이 알려지면서
멀티헤드 어텐션 층 이후에 밀집층을 더 사용하는 아키텍처가 개발되었다.
멀티헤드 어텐션 층, 밀집<font size='2'>dense</font> 층, 정규화 층, 잔차 연결을
조합한 <strong>트랜스포머 인코더</strong><font size='2'>transformer encoder</font>가 대표적이다.</p>
<div align="center"><img src="https://drek4537l1klr.cloudfront.net/chollet2/Figures/11-09.png" style="width:35%;"></div>
<p><div style="text-align: center">&lt;그림 출처: <a href="https://www.manning.com/books/deep-learning-with-python-second-edition">Deep Learning with Python(2판)</a>&gt;</div></p><p>트랜스포머 인코더에 포함된 <code class="docutils literal notranslate"><span class="pre">LayerNormalization</span></code>은
정규화를 배치 단위가 아닌 시퀀스 단위로 정규화를 실행하는 층이며,
시퀀스 데이터를 처리할 때는 <code class="docutils literal notranslate"><span class="pre">BatchNormalization</span></code> 보다 잘 작동한다.</p>
<div class="info admonition">
<p class="admonition-title">트랜스포머 디코더</p>
<p>영화 후기 등의 분석 모델은 트랜스포머 인코더만 사용한다.
반면에 예를 들어 번역 모델은  시퀀스-투-시퀀스 학습을 이용하며
이때 트랜스포머 디코더를 활용한다.</p>
</div>
<p><strong>트랜스포머 인코더 구현</strong></p>
<p>위 그림에서 설명된 트랜스포머 인코더를 층으로 구현하면 다음과 같다.
생성자의 입력값을 예를 들어 설명하면 다음과 같다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">embed_dim</span></code>: 예를 들어 <code class="docutils literal notranslate"><span class="pre">embed_dim=256</span></code>은 단어 임베딩이
<code class="docutils literal notranslate"><span class="pre">(600,</span> <span class="pre">256)</span></code> 모양의 샘플을 생성할 것을 기대함.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dense_dim</span></code>: 밀집 층에서 사용되는 유닛<font size='2'>unit</font> 개수</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_heads</span></code>: 헤드<font size='2'>head</font> 개수</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">call()</span></code> 메서드의 <code class="docutils literal notranslate"><span class="pre">attention_mask</span></code> 옵션은 <code class="docutils literal notranslate"><span class="pre">MultiHeadAttention</span></code> 층을 호출할 때
사용되며 질문<font size='2'>query</font>에 들어온 입력값의 특정 위치를 무시하려 할 때 사용한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TransformerEncoder</span><span class="p">(</span><span class="n">layers</span><span class="o">.</span><span class="n">Layer</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embed_dim</span><span class="p">,</span> <span class="n">dense_dim</span><span class="p">,</span> <span class="n">num_heads</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">embed_dim</span> <span class="o">=</span> <span class="n">embed_dim</span>  <span class="c1"># 예를 들어 256</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dense_dim</span> <span class="o">=</span> <span class="n">dense_dim</span>  <span class="c1"># 예를 들어 32</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_heads</span> <span class="o">=</span> <span class="n">num_heads</span>  <span class="c1"># 예를 들어 2</span>
        
        <span class="c1"># 어텐션 층 지정</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attention</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">MultiHeadAttention</span><span class="p">(</span>
            <span class="n">num_heads</span><span class="o">=</span><span class="n">num_heads</span><span class="p">,</span> <span class="n">key_dim</span><span class="o">=</span><span class="n">embed_dim</span><span class="p">)</span>
        
        <span class="c1"># 밀집층 블록 지정</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dense_proj</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
            <span class="p">[</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="n">dense_dim</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s2">&quot;relu&quot;</span><span class="p">),</span>
             <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="n">embed_dim</span><span class="p">),]</span>
        <span class="p">)</span>
        
        <span class="c1"># 층 정규화 지정</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">layernorm_1</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">LayerNormalization</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">layernorm_2</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">LayerNormalization</span><span class="p">()</span>

    <span class="c1"># 트랜스포머 인코더의 순전파 경로 지정</span>
    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[:,</span> <span class="n">tf</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">attention_output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attention</span><span class="p">(</span>
            <span class="n">inputs</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">attention_mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">proj_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layernorm_1</span><span class="p">(</span><span class="n">inputs</span> <span class="o">+</span> <span class="n">attention_output</span><span class="p">)</span>
        <span class="n">proj_output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dense_proj</span><span class="p">(</span><span class="n">proj_input</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">layernorm_2</span><span class="p">(</span><span class="n">proj_input</span> <span class="o">+</span> <span class="n">proj_output</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_config</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">config</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_config</span><span class="p">()</span>
        <span class="n">config</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
            <span class="s2">&quot;embed_dim&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">embed_dim</span><span class="p">,</span>
            <span class="s2">&quot;num_heads&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_heads</span><span class="p">,</span>
            <span class="s2">&quot;dense_dim&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dense_dim</span><span class="p">,</span>
        <span class="p">})</span>
        <span class="k">return</span> <span class="n">config</span>
</pre></div>
</div>
<p><strong>트랜스포머 인코더 활용 모델</strong></p>
<p>훈련셋이 입력되면 먼저 단어 임베딩을 통과시켜 하나의 단어가 가질 수 있는 일반적인 특성을 찾는다.
이후 트랜스포머 인코더로 셀프 어텐션을 적용하여 단어가 사용되는 문장에서의 문맥상의 특성을 추가한다.</p>
<p>사용되는 변수들은 다음과 같다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vocab_size</span> <span class="pre">=</span> <span class="pre">20000</span></code>: 어휘 색인 크기</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">embed_dim</span> <span class="pre">=</span> <span class="pre">256</span></code>: 단어 임베딩 특성 수</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_heads</span> <span class="pre">=</span> <span class="pre">2</span></code>: 트랜스포머 인코더에 사용되는 밀집층의 헤드(head) 수</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dense_dim</span> <span class="pre">=</span> <span class="pre">32</span></code>: 트랜스포머 인코더에 사용되는 밀집층의 유닛(unit) 수</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">inputs</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Embedding</span><span class="p">(</span><span class="n">vocab_size</span><span class="p">,</span> <span class="n">embed_dim</span><span class="p">)(</span><span class="n">inputs</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">TransformerEncoder</span><span class="p">(</span><span class="n">embed_dim</span><span class="p">,</span> <span class="n">dense_dim</span><span class="p">,</span> <span class="n">num_heads</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># 길이가 256인 1차원 어레이로 변환.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">GlobalMaxPooling1D</span><span class="p">()(</span><span class="n">x</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>

<span class="n">outputs</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s2">&quot;sigmoid&quot;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>

<span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s2">&quot;rmsprop&quot;</span><span class="p">,</span>
              <span class="n">loss</span><span class="o">=</span><span class="s2">&quot;binary_crossentropy&quot;</span><span class="p">,</span>
              <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;accuracy&quot;</span><span class="p">])</span>

<span class="n">model</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
</pre></div>
</div>
<p>훈련 과정은 특별한 게 없다.
테스트셋에 대한 정확도가 87.5% 정도로 바이그램 모델보다 좀 더 낮다.</p>
<div class="info admonition">
<p class="admonition-title">GlobalMaxPooling1D</p>
<p>벡터(1차원 텐서)로 구성된 시퀀스가 <code class="docutils literal notranslate"><span class="pre">GlobalMaxPooling1D</span></code> 층을 통과하면 벡터의 특성별로 최댓값만 추출해서 사용한다.
따라서 벡터의 길이에 해당하는 하나의 벡터가 생성된다.</p>
<p>예를 들어, (4, 2, 3) 모양의 텐서, 즉, 길이가 3인 두 개의 벡터로 구성된 시퀀스 네 개를 묶은 배치가 <code class="docutils literal notranslate"><span class="pre">GlobalMaxPooling1D</span></code> 층을
통과해서 (4, 3) 모양의 텐서가 생성된다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span>
<span class="gp">... </span>      <span class="p">[[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
<span class="gp">... </span>        <span class="p">[</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">]],</span>
<span class="gp">... </span>       <span class="p">[[</span> <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">12.</span><span class="p">],</span>
<span class="gp">... </span>        <span class="p">[</span><span class="mf">10.</span><span class="p">,</span> <span class="mf">11.</span><span class="p">,</span> <span class="mf">9.</span><span class="p">]],</span>
<span class="gp">... </span>       <span class="p">[[</span><span class="mf">16.</span><span class="p">,</span> <span class="mf">14.</span><span class="p">,</span> <span class="mf">15.</span><span class="p">],</span>
<span class="gp">... </span>        <span class="p">[</span><span class="mf">13.</span><span class="p">,</span> <span class="mf">17.</span><span class="p">,</span> <span class="mf">18.</span><span class="p">]],</span>
<span class="gp">... </span>       <span class="p">[[</span><span class="mf">19.</span><span class="p">,</span> <span class="mf">20.</span><span class="p">,</span> <span class="mf">21.</span><span class="p">],</span>
<span class="gp">... </span>        <span class="p">[</span><span class="mf">22.</span><span class="p">,</span> <span class="mf">23.</span><span class="p">,</span> <span class="mf">24.</span><span class="p">]]])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">max_pool_1d</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">GlobalMaxPooling1D</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_pool_1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">&lt;tf.Tensor: shape=(4, 3), dtype=float32, numpy=</span>
<span class="go">array([[ 4.,  5.,  6.],</span>
<span class="go">       [10., 11., 12.],</span>
<span class="go">       [16., 17., 18.],</span>
<span class="go">       [22., 23., 24.]], dtype=float32)&gt;</span>
</pre></div>
</div>
</div>
<p><strong>모델 비교</strong></p>
<p>자연어처리와 관련된 모델을 단어 순서 인식과 문맥 이해 차원에서 비교하면 다음과 같다.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head text-center"><p></p></th>
<th class="head text-center"><p>단어순서 인식</p></th>
<th class="head text-center"><p>문맥 이해</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>유니그램 주머니 모델</p></td>
<td class="text-center"><p>X</p></td>
<td class="text-center"><p>X</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>바이그램 주머니 모델</p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\triangle\)</span></p></td>
<td class="text-center"><p>X</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>RNN</p></td>
<td class="text-center"><p>O</p></td>
<td class="text-center"><p>X</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>셀프 어텐션</p></td>
<td class="text-center"><p>X</p></td>
<td class="text-center"><p>O</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>트랜스포머</p></td>
<td class="text-center"><p>O</p></td>
<td class="text-center"><p>O</p></td>
</tr>
</tbody>
</table>
<p><strong>단어 위치 인코딩</strong></p>
<p>앞서 살펴 본 트랜스포머 인코더는 셀프 어텐션과 밀집층을 사용하기에
단어순서를 제대로 활용하지는 못한다.
하지만 단어 인코딩 과정에서 단어순서 정보를 활용하도록 하는 기능을 추가하면
트랜스포머가 알아서 단어위치 정보를 활용한다.</p>
<p>다음 <code class="docutils literal notranslate"><span class="pre">PositionalEmbedding</span></code> 층 클래스는 두 개의 임베딩 클래스를 순전파에 사용한다.</p>
<ul>
<li><p>단어 임베딩</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">token_embeddings</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Embedding</span><span class="p">(</span><span class="n">input_dim</span><span class="o">=</span><span class="n">input_dim</span><span class="p">,</span> <span class="n">output_dim</span><span class="o">=</span><span class="n">output_dim</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>위치 임베딩</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">position_embeddings</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Embedding</span><span class="p">(</span><span class="n">input_dim</span><span class="o">=</span><span class="n">sequence_length</span><span class="p">,</span> <span class="n">output_dim</span><span class="o">=</span><span class="n">output_dim</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<p>순전파를 담당하는 <code class="docutils literal notranslate"><span class="pre">call()</span></code> 메서드가 호출되면
<code class="docutils literal notranslate"><span class="pre">self.token_embeddings</span></code>는 보통의 단어 임베딩을 수행하고,
<code class="docutils literal notranslate"><span class="pre">self.position_embeddings</span></code>는 단어의 위치 정보를 임베딩한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">embedded_tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_embeddings</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
<span class="n">embedded_positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_embeddings</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
</pre></div>
</div>
<p>최종적으로 각 임베딩의 출력값을 합친 값이 반환된다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PositionalEmbedding</span><span class="p">(</span><span class="n">layers</span><span class="o">.</span><span class="n">Layer</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence_length</span><span class="p">,</span> <span class="n">input_dim</span><span class="p">,</span> <span class="n">output_dim</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token_embeddings</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Embedding</span><span class="p">(</span>
            <span class="n">input_dim</span><span class="o">=</span><span class="n">input_dim</span><span class="p">,</span> <span class="n">output_dim</span><span class="o">=</span><span class="n">output_dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position_embeddings</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Embedding</span><span class="p">(</span>
            <span class="n">input_dim</span><span class="o">=</span><span class="n">sequence_length</span><span class="p">,</span> <span class="n">output_dim</span><span class="o">=</span><span class="n">output_dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">=</span> <span class="n">sequence_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span> <span class="o">=</span> <span class="n">input_dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span> <span class="o">=</span> <span class="n">output_dim</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">inputs</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">length</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">embedded_tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_embeddings</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">embedded_positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_embeddings</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">embedded_tokens</span> <span class="o">+</span> <span class="n">embedded_positions</span>

    <span class="k">def</span> <span class="nf">compute_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">not_equal</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_config</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">config</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_config</span><span class="p">()</span>
        <span class="n">config</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
            <span class="s2">&quot;output_dim&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="p">,</span>
            <span class="s2">&quot;sequence_length&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">,</span>
            <span class="s2">&quot;input_dim&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span><span class="p">,</span>
        <span class="p">})</span>
        <span class="k">return</span> <span class="n">config</span>
</pre></div>
</div>
<p><strong>단어위치 인식 트랜스포머 아키텍처</strong></p>
<p>아래 코드는 <code class="docutils literal notranslate"><span class="pre">PositionalEmbedding</span></code> 층을 활용하여 트랜스포머 인코더가
단어위치를 활용할 수 있도록 한다.
최종 모델의 테스트셋에 대한 정확도가 88.3%까지 향상됨을 확인할 수 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">vocab_size</span> <span class="o">=</span> <span class="mi">20000</span>
<span class="n">sequence_length</span> <span class="o">=</span> <span class="mi">600</span>
<span class="n">embed_dim</span> <span class="o">=</span> <span class="mi">256</span>
<span class="n">num_heads</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">dense_dim</span> <span class="o">=</span> <span class="mi">32</span>

<span class="n">inputs</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">PositionalEmbedding</span><span class="p">(</span><span class="n">sequence_length</span><span class="p">,</span> <span class="n">vocab_size</span><span class="p">,</span> <span class="n">embed_dim</span><span class="p">)(</span><span class="n">inputs</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">TransformerEncoder</span><span class="p">(</span><span class="n">embed_dim</span><span class="p">,</span> <span class="n">dense_dim</span><span class="p">,</span> <span class="n">num_heads</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">GlobalMaxPooling1D</span><span class="p">()(</span><span class="n">x</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
<span class="n">outputs</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s2">&quot;sigmoid&quot;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id16">
<h3><span class="section-number">11.4.4. </span>트랜스포머 사용 기준<a class="headerlink" href="#id16" title="Permalink to this heading">#</a></h3>
<p>단어주머니 모델이 여전히 유용하게 활용된다.
실제로 IMDB 데이터셋에 대한 성능도 단어주머니 모델이 가장 좋았다.
그리고 많은 실험 결과 “훈련셋의 크기”와 “문장의 평균 단어 수”의 비율이 모델 선택에
결정적인 역할을 수행한다는 경험 법칙이 알려졌다.</p>
<ul class="simple">
<li><p>(“훈련셋의 크기” <span class="math notranslate nohighlight">\(/\)</span> “문장의 단어 수 평균”) <span class="math notranslate nohighlight">\(&gt;\)</span> 1500 인 경우: 트랜스포머 등 순차 모델</p></li>
<li><p>(“훈련셋의 크기” <span class="math notranslate nohighlight">\(/\)</span> “문장의 단어 수 평균”) <span class="math notranslate nohighlight">\(&lt;\)</span> 1500 인 경우: 바이그램 단어주머니 모델</p></li>
</ul>
<p><strong>예제 1</strong></p>
<p>1천개의 단어를 포함한 텍스트 십만 개로 이루어진 훈련셋을 사용하는 경우 비율이 100이기에 바이그램 모델을 사용하는 것이 좋다.</p>
<p><strong>예제 2</strong></p>
<p>평균 40개의 단어를 포함하는 트윗(tweets) 5만 개로 이루어진 훈련셋을 사용하는 경우 비율이 1,250이기에 역시 바이그램 모델을 사용하는 것이 좋다.</p>
<p><strong>예제 3</strong></p>
<p>평균 40개의 단어를 포함하는 트윗(tweets) 50만 개로 이루어진 훈련셋을 사용하는 경우 비율이 12,500이기에 이번엔 트랜스포머 인코더를 활용하는 것이 좋다.</p>
<p><strong>예제 4</strong></p>
<p>IMDB 훈련셋은 2만 개의 후기로 구성되며 후기 한 개는 평균 233 개의 단어를 포함한다. 비율이 85.84 정도이기에 바이그램 모델이 보다 적합해야 하는데
지금까지 살펴본 결과가 이에 입증한다.</p>
<p><strong>경험 법칙의 직관적 이해</strong></p>
<p>짧은 문장이 많을 수록 문맥을 파악하려면 단어들의 순서가 중요하며,
문장에 사용된 단어들 사이의 복잡한 연관성을 보다 주의깊게 살펴볼 필요가 있다.
예를 들어, “그 영화는 실패야”와 “그 영화는 실패였어”는 분명 다른 의미를 가지지만
단어주머니 모델은 차이점을 파악하기 어렵다.
반면에 보다 긴 문장의 주제와 긍정/부정 등의 감성에 대한 분류는
단어 관련 통계의 중요성이 보다 크다.</p>
<p><strong>주의사항</strong></p>
<p>앞서 설명한 경험 법칙은은 텍스트 분류에 한정된다.
예를 들어 기계 번역<font size='2'>machine translation</font>의 경우 매우 긴 문장을 다룰 때
트랜스포머가 가본적으로 가장 강력한 성능의 모델을 생성한다.</p>
</section>
</section>
<section id="id17">
<h2><span class="section-number">11.5. </span>시퀀스-투-시퀀스 학습<a class="headerlink" href="#id17" title="Permalink to this heading">#</a></h2>
<p>준비중 …</p>
</section>
<section id="id18">
<h2><span class="section-number">11.6. </span>참고 문헌<a class="headerlink" href="#id18" title="Permalink to this heading">#</a></h2>
<ol class="arabic simple">
<li><p><a class="reference external" href="https://e2eml.school/transformers.html">Transformers from Scratch</a>:
트랜스포머 내부의 작동과정 자세한 설명</p></li>
<li><p><a class="reference external" href="https://keras.io/guides/keras_nlp/getting_started/">KerasNLP</a>: KerasNLP 소개</p></li>
</ol>
</section>
<section id="id19">
<h2><span class="section-number">11.7. </span>연습 문제<a class="headerlink" href="#id19" title="Permalink to this heading">#</a></h2>
<ol class="arabic simple">
<li><p><a class="reference external" href="https://colab.research.google.com/github/codingalzi/dlp2/blob/master/excs/exc-dl_for_text.ipynb">(실습) 자연어 처리</a></p></li>
</ol>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  <!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="dl_for_timeseries.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">10. </span>시계열 분석</p>
      </div>
    </a>
    <a class="right-next"
       href="generative_dl.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">12. </span>생성 모델</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">11.1. 자연어 처리 소개</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">11.2. 텍스트 데이터 전처리</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">11.2.1. 문장 표준화</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">11.2.2. 토큰화</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">11.2.3. 어휘 색인화</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">11.3. 단어 주머니와 단어 임베딩</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#imdb">11.3.1. IMDB 영화 후기 데이터셋 준비</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">11.3.2. 단어 주머니 활용법</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">11.3.3. 시퀀스 활용법</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">11.3.3.1. 원-핫 단어 벡터</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">11.3.3.2. 단어 임베딩</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#glove">11.3.3.3. GloVe 단어 임베딩</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">11.4. 트랜스포머 아키텍처</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">11.4.1. 셀프 어텐션</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">11.4.2. 멀티헤드 어텐션</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">11.4.3. 트랜스포머 인코더</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id16">11.4.4. 트랜스포머 사용 기준</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id17">11.5. 시퀀스-투-시퀀스 학습</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id18">11.6. 참고 문헌</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id19">11.7. 연습 문제</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By 코딩알지
</p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=ac02cc09edc035673794"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=ac02cc09edc035673794"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>