
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>4. 케라스와 텐서플로우 &#8212; Deep Learning with Python(2판)</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css?v=ca93fcec" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'keras_and_tf';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="5. 신경망 활용 처음부터 끝까지: 분류와 회귀" href="getting_started_with_neural_networks.html" />
    <link rel="prev" title="3. 텐서" href="tf_tensor.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
  
  
    <p class="title logo__title">Deep Learning with Python(2판)</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="what_is_deep_learning.html">1. 딥러닝 소개</a></li>
<li class="toctree-l1"><a class="reference internal" href="building_blocks_of_NN.html">2. 신경망 기본 구성 요소</a></li>
<li class="toctree-l1"><a class="reference internal" href="tf_tensor.html">3. 텐서</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">4. 케라스와 텐서플로우</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started_with_neural_networks.html">5. 신경망 활용 처음부터 끝까지: 분류와 회귀</a></li>
<li class="toctree-l1"><a class="reference internal" href="fundamentals_of_ml.html">6. 머신러닝 모델 훈련 기법</a></li>
<li class="toctree-l1"><a class="reference internal" href="unversal_workflow_of_ml.html">7. 머신러닝 작업 흐름 일반</a></li>
<li class="toctree-l1"><a class="reference internal" href="working_with_keras.html">8. 케라스 신경망 모델 활용법</a></li>
<li class="toctree-l1"><a class="reference internal" href="computer_vision_intro.html">9. 컴퓨터 비전 기초: 합성곱 신경망</a></li>
<li class="toctree-l1"><a class="reference internal" href="computer_vision_advanced.html">10. 고급 컴퓨터 비전</a></li>
<li class="toctree-l1"><a class="reference internal" href="dl_for_timeseries.html">11. 시계열 분석</a></li>
<li class="toctree-l1"><a class="reference internal" href="dl_for_text.html">12. 자연어 처리</a></li>
<li class="toctree-l1"><a class="reference internal" href="generative_dl.html">13. 생성 모델</a></li>
<li class="toctree-l1"><a class="reference internal" href="best_practices.html">14. 딥러닝 실전 적용</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/codingalzi/dlp2" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/codingalzi/dlp2/issues/new?title=Issue%20on%20page%20%2Fkeras_and_tf.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/keras_and_tf.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>케라스와 텐서플로우</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">4.1. 딥러닝 주요 라이브러리</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">4.1.1. 텐서플로우</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">4.1.2. 케라스</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">4.1.3. 딥러닝 주요 라이브러리 약력</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">4.1.4. 딥러닝 개발환경</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">4.2. 텐서플로우 활용법 기초</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#api">4.3. 케라스 신경망 모델의 핵심 API</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">4.3.1. 층</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">4.3.2. 모델</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">4.3.3. 훈련 루프</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">4.3.4. 예측</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">4.4. 연습 문제</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="ch-keras-tf">
<span id="id1"></span><h1><span class="section-number">4. </span>케라스와 텐서플로우<a class="headerlink" href="#ch-keras-tf" title="Link to this heading">#</a></h1>
<p><strong>감사의 글</strong></p>
<p>아래 내용은 프랑소와 숄레의
<a class="reference external" href="https://github.com/fchollet/deep-learning-with-python-notebooks">Deep Learning with Python(2판)</a>의
소스코드 내용을 참고해서 작성되었습니다.
자료를 공개한 저자에게 진심어린 감사를 전합니다.</p>
<p><strong>소스코드</strong></p>
<p>여기서 언급되는 코드를
<a class="reference external" href="https://colab.research.google.com/github/codingalzi/dlp2/blob/master/notebooks/NB-keras_and_tf.ipynb">(구글 코랩) 케라스와 텐서플로우</a>에서
직접 실행할 수 있다.</p>
<p><strong>슬라이드</strong></p>
<p>본문 내용을 요약한 <a class="reference external" href="https://github.com/codingalzi/dlp2/raw/master/slides/slides-keras_and_tf.pdf">슬라이드</a>를 다운로드할 수 있다.</p>
<p><strong>주요 내용</strong></p>
<p>케라스와 텐서플로우를 이용한 딥러닝의 활용법을 소개한다.</p>
<section id="id2">
<h2><span class="section-number">4.1. </span>딥러닝 주요 라이브러리<a class="headerlink" href="#id2" title="Link to this heading">#</a></h2>
<section id="id3">
<h3><span class="section-number">4.1.1. </span>텐서플로우<a class="headerlink" href="#id3" title="Link to this heading">#</a></h3>
<p>텐서플로우는 파이썬에 기반한 머신러닝 플랫폼이며,
머신러닝 모델의 훈련에 필요한 텐서 연산을 지원한다.
넘파이<font size='2'>Numpy</font> 패키지와 유사하지만 보다 많은 기능을 제공한다.</p>
<ul class="simple">
<li><p>그레이디언트 자동 계산</p></li>
<li><p>GPU, TPU 등 고성능 병렬 하드웨어 가속기 활용 가능</p></li>
<li><p>여러 대의 컴퓨터 또는 클라우드 컴퓨팅 서비스 활용 가능</p></li>
<li><p>C++(게임), 자바스크립트(웹브라우저), TFLite(모바일 장치) 등과 호환 가능</p></li>
</ul>
<p>텐서플로우는 또한 단순한 패키지 기능을 넘어서는 머신러닝 플랫폼 역할도 수행한다.</p>
<ul class="simple">
<li><p>TF-Agents: 강화학습 연구 지원</p></li>
<li><p>TFX: 머신러닝 프로젝트 운영 지원</p></li>
<li><p>TensorFlow-Hub: 사전 훈련된 머신러닝 모델 제공</p></li>
</ul>
</section>
<section id="id4">
<h3><span class="section-number">4.1.2. </span>케라스<a class="headerlink" href="#id4" title="Link to this heading">#</a></h3>
<p>딥러닝 모델 구성 및 훈련에 효율적으로 사용될 수 있는 다양한 수준의 API를 제공하며,
텐서플로우의 프론트엔드<font size='2'>front end</font> 인터페이스 기능을 수행한다.
원래 텐서플로우와 독립적으로 개발되었지만 텐서플로우 2.0부터 텐서플로우 라이브러리의 최상위 프레임워크<font size='2'>framework</font>로 포함됐다.</p>
<div align="center"><img src="https://drek4537l1klr.cloudfront.net/chollet2/v-7/Figures/keras_and_tf.png" style="width:600px;"></div>
<p><div style="text-align: center">&lt;그림 출처: <a href="https://www.manning.com/books/deep-learning-with-python-second-edition">Deep Learning with Python(2판)</a>&gt;</div></p><div class="note admonition">
<p class="admonition-title">모듈, 패키지, 라이브러리, 프레임워크</p>
<p>한 번 구현한 파이썬 코드를 다른 파이썬 파일의 코드에서 공유해서 사용할 수 있도록 하기 위해 모듈<font size='2'>module</font>을 활용한다.
파이썬 모듈은 간단하게 말하면 하나의 파이썬 소스코드 파일이며, 확장자로 .py 가 사용된다. 모듈에는 보통 서로 연관된 함수와 클래스 등을 저장한다.
하나의 모듈이 독립적으로 제공되기도 하지만 다른 모듈과 함께 하나의 모음집으로 제공되기도 한다.
모음집의 크기와 용도에 따라 패키지, 라이브러리, 프레임워크 등 다양한 이름으로 불린다.</p>
<ul class="simple">
<li><p>패키지<font size='2'>package</font>: 모듈을 모아놓은 디렉토리(폴더)</p></li>
<li><p>라이브러리<font size='2'>library</font>: 모듈, 패키지 등 재사용이 가능한 코드의 모음집을 통칭헤서 부르는 이름</p></li>
<li><p>프레임워크<font size='2'>framework</font>: 라이브러리 보다 포괄적인 개념.
라이브러리가 도구 모음집만 제공하는 반면에 프레임워크는 라이브러리와 함께 라이브러리를 쉽게 적용할 수 있는
틀<font size='2'>frame</font>과 아키텍처<font size='2'>architecture</font>를 함께 제공</p></li>
</ul>
</div>
</section>
<section id="id5">
<h3><span class="section-number">4.1.3. </span>딥러닝 주요 라이브러리 약력<a class="headerlink" href="#id5" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>2007년: 씨아노<font size='2'>Theano</font> 공개.
텐서를 이용한 계산 그래프, 미분 자동화 등을 최초로 지원한 딥러닝 라이브러리.</p></li>
<li><p>2015년 3월: 케라스 라이브러리 공개. Theano를 백앤드로 사용하는 고수준 패키지.</p></li>
<li><p>2015년 11월: 텐서플로우 라이브러리 공개.</p></li>
<li><p>2016년: 텐서플로우가 케라스의 기본 백엔드로 지정됨.</p></li>
<li><p>2016년 9월: 페이스북이 개발한 파이토치<font size='2'>PyTorch</font> 공개.</p></li>
<li><p>2017년: Theano, 텐서플로우, CNTK(마이크로소프트), MXNet(아마존)이 케라스의 백엔드로 지원됨.
현재 Theano, CNTK 등은 더 이상 개발되지 않으며, MXNet은 아마존에서만 주로 사용됨.</p></li>
<li><p>2018년 3월: PyTorch와 Caffe2를 합친 PyTorch 출시(페이스북과 마이크로소프트의 협업)</p></li>
<li><p>2019년 9월: 텐서플로우 2.0부터 케라스가 텐서플로우의 최상위 프레임워크로 지정됨.</p></li>
<li><p>2023년 가을: Keras Core가 케라스 3.0으로 출시 예정. 텐서플로우, PyTorch, JAX의 프론트엔드 기능 지원.</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">Keras Core</p>
<p>파이토치 또한 텐서 연산을 지원하는 딥러닝 라이브러리이다.
텐서플로우와 케라스의 조합이 강력하지만 신경망의 보다 섬세한 조정은 약하다는 지적을 많이 받는 반면에
파이토치는 상대적으로 보다 자유롭게 신경망을 구성할 수 있다고 평가된다.
텐서플로우와 케라스의 조합이 여전히 보다 많이 사용되지만 딥러닝 연구에서 파이토치의 활용 또한 점점 늘고 있다.
선호도에 대한 논쟁이 지난 몇 년간 있어 왔지만 상대적으로 약해질 것으로 기대된다.
이유는 케라스 3.0부터 텐서플로우뿐만 아니라 파이토치도 케라스의 지원을 받기 때문이다.</p>
<div align="center"><img src="https://github.com/codingalzi/dlp2/blob/master/jupyter-book/imgs/ch03-keras-core.png?raw=true" style="width:500px;"></div>
</div>
</section>
<section id="id6">
<h3><span class="section-number">4.1.4. </span>딥러닝 개발환경<a class="headerlink" href="#id6" title="Link to this heading">#</a></h3>
<p>딥러닝 신경망 모델의 훈련을 위해서 GPU를 활용할 것을 강력히 추천한다.
GPU를 사용하지 않으면 모델의 훈련이 너무 느려진다.
<a class="reference external" href="https://colab.research.google.com/?hl=ko">구글 코랩</a>을 이용하면
특별한 준비 없이 바로 신경망 모델을 GPU와 함께 훈련시킬 수 있다.
구글 코랩은 주피터 노트북을 사용하는데, 주피터 노트북 사용법과
구글 코랩에서 GPU를 이용하는 방법은 검색을 통해 쉽게 확인할 수 있다.</p>
<p>하지만 딥러닝 모델 훈련을 많이 시키려면 NVIDIA 그래픽카드가 장착된
개인용 컴퓨터를 활용하는 것이 좋다.
운영체제는 <a class="reference external" href="https://ubuntu.com/download/desktop">Ubuntu</a> 또는 윈도우 11을 추천한다.</p>
<ul class="simple">
<li><p>윈도우 11에서 GPU를 지원 텐서플로우 설치: <a class="reference external" href="https://github.com/codingalzi/dlp2/blob/master/INSTALL.md">WSL2에 NVIDIA CUDA 드라이버 12.0, Toolkit 과 cuDNN 설치</a> 참고</p></li>
<li><p>우분투에서 GPU 지원하는 텐서플로우 설치: <a class="reference external" href="https://github.com/ageron/handson-ml3/blob/main/INSTALL.md">Anaconda와 conda 환경 활용</a> 참고</p></li>
</ul>
<p>보다 전문적인 딥러닝 연구를 위해 대용량의 메모리와 고성능의 CPU, GPU가 필요한 경우
직접 모든 장비를 마련하기는 어려울 수 있다.
대신 <a class="reference external" href="https://cloud.google.com/">구글 클라우드 플랫폼</a> 또는
<a class="reference external" href="https://aws.amazon.com/ko/?nc2=h_lg">아마존 웹서비스(AWS EC2)</a> 등에서
유료로 지원되는
고성능 클라우드 컴퓨팅 서비스를 활용하는 것이
경우에 따라 상대적으로 많이 저렴할 수 있다.</p>
</section>
</section>
<section id="id7">
<h2><span class="section-number">4.2. </span>텐서플로우 활용법 기초<a class="headerlink" href="#id7" title="Link to this heading">#</a></h2>
<p>텐서플로의 텐서 자료형의 가장 큰 장점은 함수의 미분을 지원한다는 점이다.</p>
<p><strong>그레이디언트 테이프</strong></p>
<p>텐서플로의 텐서 자료형과 넘파이 어레이와의 가장 큰 차이점은
<strong>그레이디언트 테이프</strong><font size='2'>GradientTape</font> 기능을 이용하여 변수 텐서에 의존하는 미분가능한
함수의 그레이디언트 자동 계산이다.
예를 들어 아래 코드는 제곱 함수의 <span class="math notranslate nohighlight">\(x = 3\)</span>에서의 미분값인 6을 계산한다.</p>
<div class="math notranslate nohighlight">
\[
f(x) = x^2 \quad \Longrightarrow \quad \nabla f(x) = \frac{df(x)}{dx} = 2x
\]</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">input_var</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">initial_value</span><span class="o">=</span><span class="mf">3.</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">tf</span><span class="o">.</span><span class="n">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">input_var</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">gradient</span> <span class="o">=</span> <span class="n">tape</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">input_var</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">gradient</span><span class="p">)</span>
<span class="go">tf.Tensor(6.0, shape=(), dtype=float32)</span>
</pre></div>
</div>
<p><strong>예제: 선형 이진 분류기</strong></p>
<p>케라스를 전혀 사용하지 않으면서 간단한 선형 분류기를 구현하는 과정을 통해
텐서플로우 API의 기본 기능을 살펴 본다.
케라스 없이 텐서플로우만 이용해서 신경망 모델을 지정하고 훈련시킬 수 있다.
하지만 아래에 언급된 개념, 기능, 도구를 모두 직접 구현해야 한다.</p>
<ul class="simple">
<li><p>가중치, 편향 등을 저장할 텐서 지정</p></li>
<li><p>순전파 실행(덧셈, 행렬 곱, <code class="docutils literal notranslate"><span class="pre">relu()</span></code> 함수 등 활용)</p></li>
<li><p>역전파 실행</p></li>
<li><p>층과 모델</p></li>
<li><p>손실 함수</p></li>
<li><p>옵티마이저</p></li>
<li><p>평가지표</p></li>
<li><p>훈련 루프</p></li>
</ul>
<p><strong>1단계: 데이터셋 생성</strong></p>
<p>아래 사진 모양처럼 양성(노랑색)과 음성(보라색)으로 구분되는 훈련셋을 생성해서
훈련셋으로 이용한다.
생성되는 훈련셋은 다변량 정규분포를 따르도록 하며,
양성과 음성 데이터셋 각각 1,000개의 샘플로 구성된다.
데이터셋 생성에 사용되는 공분산은 두 데이터셋에 대해 동일하고 평균값만 서로 다르다.</p>
<div align="center"><img src="https://drek4537l1klr.cloudfront.net/chollet2/Figures/03-07.png" style="width:500px;"></div>
<p><div style="text-align: center">&lt;그림 출처: <a href="https://www.manning.com/books/deep-learning-with-python-second-edition">Deep Learning with Python(2판)</a>&gt;</div></p><p><code class="docutils literal notranslate"><span class="pre">np.random.multivariate.normal()</span></code> 함수는 다변량 정규 분포를 이용하여 지정된 크기의 데이터셋을 생성하며,
사용된 인자의 의미는 다음과 같다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mean</span></code>: 데이터셋의 축별 평균값</p>
<ul>
<li><p>음성 데이터셋</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> 좌표의 평균값 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code> 좌표의 평균값 3</p></li>
</ul>
</li>
<li><p>양성 데이터셋</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> 좌표의 평균값 3</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code> 좌표의 평균값 0</p></li>
</ul>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">cov=[[1,</span> <span class="pre">0.5],[0.5,</span> <span class="pre">1]]</span></code>: 공분산 지정</p>
<ul>
<li><p>0번 특성과 1번 특성의 분포를 1대 0.5 비율로 지정.</p></li>
<li><p>따라서 0번 특성의 축(x-축)으로 보다 넓게 분포됨.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">size=1000</span></code>: 생성되는 데이터셋의 크기</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">num_samples_per_class</span> <span class="o">=</span> <span class="mi">1000</span>

<span class="c1"># 음성 데이터셋</span>
<span class="n">negative_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
    <span class="n">mean</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">cov</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">size</span><span class="o">=</span><span class="n">num_samples_per_class</span><span class="p">)</span>

<span class="c1"># 양성 데이터셋</span>
<span class="n">positive_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
    <span class="n">mean</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">cov</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">size</span><span class="o">=</span><span class="n">num_samples_per_class</span><span class="p">)</span>
</pre></div>
</div>
<p>두 데이터셋을 합쳐서 훈련셋, 즉, 모델의 입력값으로 지정한다.
<code class="docutils literal notranslate"><span class="pre">np.vstack()</span></code> 함수는 여러 개의 데이터셋을 위아래로 쌓는다.
자료형을 <code class="docutils literal notranslate"><span class="pre">np.float32</span></code>로 지정함에 주의하라.
그렇게 하지 않으면 기본 자료형인 <code class="docutils literal notranslate"><span class="pre">np.float64</span></code>로 지정되어 보다 많은 메모리와 실행시간을 요구한다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">negative_sample</span></code>: (1000, 2) 모양의 텐서</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">positive_sample</span></code>: (1000, 2) 모양의 텐서</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inputs</span> <span class="pre">=</span> <span class="pre">np.vstack(negative_sample,</span> <span class="pre">positive_sample)</span></code>: (2000, 2) 모양의 텐서</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">negative_sample</span></code> 데이터셋이 0번부터 999번까지 인덱스.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">positive_sample</span></code> 데이터셋이 1000번부터 1999번까지 인덱스.</p></li>
</ul>
</li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">inputs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">negative_samples</span><span class="p">,</span> <span class="n">positive_samples</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
</pre></div>
</div>
<p>음성 샘플의 라벨은 0, 양성 샘플의 라벨은 1로 지정한다.
라벨 데이터셋 또한 2차원 어레이로 지정됨에 주의하라.
이유는 케라스의 신경망 모델은 하나의 입력 샘플에 대해 여러 종류의 예측값을 계산하도록 설계되어 있기 때문에
여기서처럼 입력 샘플 각각에 대해 양성/음성 여부 하나만 예측하더라도 길이가 1인 벡터로 출력값이 계산된다.
즉, 층에 사용되는 유닛이 하나라 하더라도 스칼라가 아닌 길이가 1인 벡터로 층의 출력값이 계산된다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">np.zeros((num_samples_per_class,</span> <span class="pre">1),</span> <span class="pre">dtype=&quot;float32&quot;)</span></code>: (1000, 1) 모양의 어레이. 0으로 채워짐.
0번부터 999번 인덱스까지의 모든 음성 데이터의 타깃은 0임.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">np.ones((num_samples_per_class,</span> <span class="pre">1),</span> <span class="pre">dtype=&quot;float32&quot;)</span></code>: (1000, 1) 모양의 어레이. 1로 채워짐.
999번부터 1999번 인덱스까지의 모든 양성 데이터의 타깃은 1임.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">targets</span></code>: (2000, 1) 모양의 어레이.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">targets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_samples_per_class</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">),</span>
                     <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">num_samples_per_class</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)))</span>
</pre></div>
</div>
<p><strong>2단계: 선형 회귀 모델 훈련에 필요한 가중치 변수 텐서와 편향 변수 텐서 생성</strong></p>
<p>선형 분류기 모델의 예측값 계산은 다음과 같이 아핀 변환으로 이뤄진다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">inputs</span> <span class="o">@</span> <span class="n">W</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">inputs</span></code>: (2000, 2) 모양의 입력 데이터셋 행렬</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">W</span></code>: (2, 1) 모양의 가중치 행렬</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inputs</span> <span class="pre">&#64;</span> <span class="pre">W</span></code>: (2000, 1) 모양의 행렬</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code>: (1,) 모양의 편향 벡터</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inputs</span> <span class="pre">&#64;</span> <span class="pre">W</span> <span class="pre">+</span> <span class="pre">b</span></code>: (2000, 1) 모양의 출력값 행렬. 즉, 2000 개의 입력 데이터 각각에 대해 하나의 값의 계산됨.</p></li>
</ul>
<p>위 식을 구현하기 위해 먼저 아핀 변환에 사용될 가중치 행렬과 편향 벡터를 각각
(2000, 2) 모양의 변수 텐서와 (1, ) 모양의 변수 텐서로 선언한다.
<code class="docutils literal notranslate"><span class="pre">input_dim</span></code>과 <code class="docutils literal notranslate"><span class="pre">output_dim</span></code> 은 각각 입력 샘플의 차원고하 출력 샘플의 차원을 가리킨다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">input_dim</span> <span class="o">=</span> <span class="mi">2</span>     <span class="c1"># 입력 샘플의 특성이 2개</span>
<span class="n">output_dim</span> <span class="o">=</span> <span class="mi">1</span>    <span class="c1"># 각각의 입력 샘플에 대해 하나의 부동소수점을 예측값으로 계산</span>
</pre></div>
</div>
<p>가중치 행렬은 정규 분포를 이용하여 무작위로, 편향 벡터는 0 벡터로 초기화 한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 가중치: (2, 1) 모양의 가중치 행렬을 균등분포를 이용한 무작위 초기화</span>
<span class="n">W</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">initial_value</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">input_dim</span><span class="p">,</span> <span class="n">output_dim</span><span class="p">)))</span>

<span class="c1"># 편향: (1,) 모양의 벡터를 0으로 초기화</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">initial_value</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">output_dim</span><span class="p">,)))</span>
</pre></div>
</div>
<p><strong>3단계: 모델 선언(포워드 패스)</strong></p>
<p>아래 <code class="docutils literal notranslate"><span class="pre">dense()</span></code> 함수는 밀집층(dense layer)에서의 아핀 변환을 담당한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dense</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">W</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span>
    <span class="k">if</span> <span class="n">activation</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">activation</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">outputs</span>
</pre></div>
</div>
<p>신경망 모델을 훈련할 때 입력값에 대한 예측값을 계산하는 과정인
포워드 패스를 함수로 구현한다.
여기서는 간단한 모델 표현을 위해 하나의 유닛으로 구성된 층 하나로 구성된 모델을 설정한다.
즉, 앞서 언급한 아핀 변환으로 바로 모델의 출력값을 계산하는 모델을 사용한다.
또한 보다 간단한 설명을 위해 활성화 함수는 사용하지 않는다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="n">dense</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">outputs</span>
</pre></div>
</div>
<p><strong>4단계: 손실 함수 지정</strong></p>
<p>타깃과 예측값 사이의 평균 제곱 오차를 손실값으로 사용한다.
아래 식에서 <span class="math notranslate nohighlight">\(m_b\)</span>은 배치 크기를 가리킨다.</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{m_b}\sum (y - \hat y)^2
\]</div>
<p>아래 코드에서 <code class="docutils literal notranslate"><span class="pre">tf.reduce_mean()</span></code> 함수는 텐서 항목들의 평균값을 계산한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">square_loss</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="n">predictions</span><span class="p">):</span>
    <span class="n">per_sample_losses</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">targets</span> <span class="o">-</span> <span class="n">predictions</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">per_sample_losses</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>5단계: 훈련 스텝(역전파) 지정</strong></p>
<p>아래 <code class="docutils literal notranslate"><span class="pre">training_step()</span></code> 함수는
하나의 배치 입력 데이터셋에 대해 역전파 기능을 수행한다.</p>
<ul class="simple">
<li><p>그레이디언트 테이프</p>
<ul>
<li><p>모델의 예측값을 이용하여 손실 함수 계산</p></li>
<li><p>손실 함수의 그레이디언트 계산 준비</p></li>
</ul>
</li>
<li><p>가중치 변수 텐서와 편향 변수 텐서에 대한 손실 함수의 그레이디언트 계산</p></li>
<li><p>가중치 행렬과 편향 벡터 업데이트</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">training_step</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">targets</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    - inputs: 입력 데이터 배치</span>
<span class="sd">    - targets: 타깃 배치</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># 손실 함수의 그레이디언트 계산 준비</span>
    <span class="k">with</span> <span class="n">tf</span><span class="o">.</span><span class="n">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">square_loss</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="n">predictions</span><span class="p">)</span>

    <span class="c1"># 가중치와 편향에 대한 손실 함수의 그레이디언트 계산</span>
    <span class="n">grad_loss_wrt_W</span><span class="p">,</span> <span class="n">grad_loss_wrt_b</span> <span class="o">=</span> <span class="n">tape</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="p">[</span><span class="n">W</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
    
    <span class="c1"># 가중치 행렬과 편향 벡터 업데이트</span>
    <span class="n">W</span><span class="o">.</span><span class="n">assign_sub</span><span class="p">(</span><span class="n">grad_loss_wrt_W</span> <span class="o">*</span> <span class="n">learning_rate</span><span class="p">)</span> <span class="c1"># 가중치 행렬 업데이트</span>
    <span class="n">b</span><span class="o">.</span><span class="n">assign_sub</span><span class="p">(</span><span class="n">grad_loss_wrt_b</span> <span class="o">*</span> <span class="n">learning_rate</span><span class="p">)</span> <span class="c1"># 편향 업데이트</span>
    
    <span class="k">return</span> <span class="n">loss</span>
</pre></div>
</div>
<p><strong>6단계: 훈련 루프 지정</strong></p>
<p>반복해서 훈련한 내용을 출력한다.
여기서는 설명을 간단하게 하기 위해 전체 데이터셋을 하나의 배치로 사용하는 훈련을 구현한다.
전체 훈련셋을 총 40번 반복 학습할 때마다 손실값을 출력하도록 한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">40</span><span class="p">):</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">training_step</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">targets</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loss at step </span><span class="si">{</span><span class="n">step</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">loss</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>7단계: 결정경계</strong></p>
<p>모델의 예측값이 0.5보다 클 때 양성으로 판정한다.
이유는 샘플들의 라벨이 0 또는 1이기 때문이다.
모델은 훈련과정 중에 음성 샘플은 최대한 0에,
양성 샘플은 최대한 1에 가까운 값으로 예측하여 손실값을 최대한 줄여야 하는데
<code class="docutils literal notranslate"><span class="pre">training_step()</span></code> 함수에서 구현된 경사하강법이 그렇게 유도한다.
따라서 예측값이 0과 1의 중간값인 0.5일 때를 결정경계로 사용한다.</p>
<p>결정경계를 직선으로 그리려면 아래 일차 함수를 이용한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">y</span> <span class="o">=</span> <span class="o">-</span> <span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span>  <span class="n">W</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="n">W</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>이유는 아래 식으로 계산되는 모델의 예측값이
0.5보다 큰지 여부에 따라 양성/음성이 판단되기 때문이다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">W</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<div align="center"><img src="https://github.com/codingalzi/dlp2/blob/master/jupyter-book/imgs/ch03-bin_classification.png?raw=true" style="width:500px;"></div></section>
<section id="api">
<h2><span class="section-number">4.3. </span>케라스 신경망 모델의 핵심 API<a class="headerlink" href="#api" title="Link to this heading">#</a></h2>
<p>신경망 모델은 층<font size='2'>layer</font>으로 구성된다.
모델에 사용되는 층의 종류와 층을 쌓는 방식에 따라
모델이 처리할 수 있는 데이터와 훈련 방식이 달라지는데
케라스 라이브러리가 층을 구성하고 훈련 방식을 관장하는 다양한 API를 제공한다.</p>
<section id="id8">
<h3><span class="section-number">4.3.1. </span>층<a class="headerlink" href="#id8" title="Link to this heading">#</a></h3>
<p><strong>층의 기능</strong></p>
<p>층은 입력 데이터를 지정된 방식에 따라 다른 모양의 데이터로 변환하는
<strong>포워드 패스</strong><font size='2'>forward pass</font>를 담당한다.
또한 데이터 변환에 사용되는 가중치<font size='2'>weight</font>와 편향<font size='2'>bias</font>도
저장한다.</p>
<p><strong>층의 종류</strong></p>
<p>층의 종류에 따라 입력 배치 데이터셋 텐서의 모양이 달라진다.
많이 사용되는 층 클래스는 다음과 같다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Dense</span></code> 클래스</p>
<ul>
<li><p>밀집층 생성</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(배치</span> <span class="pre">크기,</span> <span class="pre">특성</span> <span class="pre">수)</span></code> 모양의 2D 텐서로 입력된 데이터셋 처리.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">LSTM</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">Conv1D</span></code> 클래스</p>
<ul>
<li><p>순차 데이터와 시계열 데이터 분석에 사용되는 순환층 생성</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(배치</span> <span class="pre">크기,</span> <span class="pre">타임스텝</span> <span class="pre">수,</span> <span class="pre">특성</span> <span class="pre">수)</span></code> 모양의 3D 텐서로 입력된 순차 데이터셋 처리.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Conv2D</span></code> 클래스</p>
<ul>
<li><p>합성곱 신경망(CNN) 구성에 사용되는 합성곱층 생성</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(배치</span> <span class="pre">크기,</span> <span class="pre">가로,</span> <span class="pre">세로,</span> <span class="pre">채널</span> <span class="pre">수)</span></code> 모양의 4D 텐서로 제공된 이미지 데이터셋 처리.</p></li>
</ul>
</li>
</ul>
<p>케라스를 활용하여 딥러닝 모델을 구성하는 일은 호환 가능한 층들을 적절하게 연결하여 층을 쌓는 것을 의미한다.</p>
<p><strong><code class="docutils literal notranslate"><span class="pre">tf.keras.layers.Layer</span></code> 클래스</strong></p>
<p>케라스의 모든 층 클래스는 <code class="docutils literal notranslate"><span class="pre">tf.keras.layers.Layer</span></code> 클래스를 상속한다.
그리고 상속되는 <code class="docutils literal notranslate"><span class="pre">__call__()</span></code> 메서드가
가중치와 편향 텐서를 초기화하고 입력 데이터셋을 출력 데이터셋으로 변환하는
포워드 패스를 수행한다.
단, 가중치와 편향이 이미 생성되어 있다면 새로 생성하지 않고 그대로 사용한다.</p>
<p><code class="docutils literal notranslate"><span class="pre">tf.keras.layers.Layer</span></code> 클래스에서 선언된 <code class="docutils literal notranslate"><span class="pre">__call__()</span></code> 메서드가 하는 일을 간략하게 나타내면 다음과 같다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">built</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">built</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
</pre></div>
</div>
<p>위 코드에 사용된 인스턴스 변수와 메서드는 다음과 같으며 모두
<code class="docutils literal notranslate"><span class="pre">tf.keras.layers.Layer</span></code>로부터 상속된다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self.built</span></code>: 모델 훈련에 사용될 가중치와 편향이 준비되어 있는지 여부 기억</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">self.build(inputs.shape)</span></code>: 입력 데이터셋의 모양 정보를 이용하여
적절한 모양의 가중치 텐서와 편향 텐서를 생성하고 초기화한다.</p>
<ul>
<li><p>가중치 텐서 초기화: 정규 분포를 이용한 무작위 초기화</p></li>
<li><p>편향 텐서 초기화: 0 벡터로 초기화</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">self.call(inputs)</span></code>: 아핀 변환, 활성화 함수 등을 이용한 포워드 패스.
즉 입력 데이터셋을 출력 텐서로 변환해서 반환</p></li>
</ul>
<p><strong><code class="docutils literal notranslate"><span class="pre">Dense</span></code> 클래스 직접 구현하기</strong></p>
<p><a class="reference internal" href="building_blocks_of_NN.html#sec-nn-mnist"><span class="std std-numref">2.1절</span></a>에서 MNIST 데이터셋을 이용한 분류 모델에 사용된
신경망 모델은 연속으로 쌓은 두 개의 <code class="docutils literal notranslate"><span class="pre">Dense</span></code> 층으로 구성된다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span>
    <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s2">&quot;relu&quot;</span><span class="p">),</span>
    <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s2">&quot;softmax&quot;</span><span class="p">)</span>
<span class="p">])</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Dense</span></code> 클래스와 유사하게 작동하는 클래스를 직접 정의하려면
상속해야 하는 <code class="docutils literal notranslate"><span class="pre">keras.layers.Layer</span></code> 클래스의 <code class="docutils literal notranslate"><span class="pre">__call()__</span></code> 메서드에 의해 호출되는
<code class="docutils literal notranslate"><span class="pre">build()</span></code> 메서드와 <code class="docutils literal notranslate"><span class="pre">call()</span></code> 메서드를 구현해야 한다.
아래 <code class="docutils literal notranslate"><span class="pre">SimpleDense</span></code> 클래스가 <code class="docutils literal notranslate"><span class="pre">Dense</span></code> 클래스의 기능을 단순화하여 구현한다.</p>
<p>두 메서드의 정의에 사용된 매개변수와 메서드는 다음과 같다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">units</span></code>: 출력 샘플의 특성 수 지정</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">activation</span></code>: 활성화 함수 지정</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">input_shape</span></code>: 입력값(<code class="docutils literal notranslate"><span class="pre">inputs</span></code>)으로 얻은 입력 배치의 2D 모양 정보. 둘째 항목이 입력 샘플의 특성 수.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">add_weight(모양,</span> <span class="pre">초기화방법)</span></code>: 지정된 모양의 텐서 생성 및 초기화. <code class="docutils literal notranslate"><span class="pre">Layer</span></code> 클래스에서 상속.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">tensorflow</span> <span class="kn">import</span> <span class="n">keras</span>

<span class="k">class</span> <span class="nc">SimpleDense</span><span class="p">(</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Layer</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">units</span>           <span class="c1"># 유닛 개수 지정</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation</span> <span class="o">=</span> <span class="n">activation</span> <span class="c1"># 활성화 함수 지정</span>

    <span class="c1"># 가중치와 편향 초기화</span>
    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_shape</span><span class="p">):</span>
        <span class="n">input_dim</span> <span class="o">=</span> <span class="n">input_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="c1"># 입력 샘플의 특성 수</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_weight</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">input_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">),</span>
                                 <span class="n">initializer</span><span class="o">=</span><span class="s2">&quot;random_normal&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_weight</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,),</span>
                                 <span class="n">initializer</span><span class="o">=</span><span class="s2">&quot;zeros&quot;</span><span class="p">)</span>

    <span class="c1"># 데이터 변환(포워드 패스)</span>
    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y</span>
</pre></div>
</div>
<div class="proof example admonition" id="simpledense">
<p class="admonition-title"><span class="caption-number">Example 4.1 </span> (<code class="docutils literal notranslate"><span class="pre">SimpleDense</span></code> 층의 데이터 변환)</p>
<section class="example-content" id="proof-content">
<p>모델 훈련 과정에서 포워드 패스는 층에서 층으로 이어지는 연속된 데이터 변환으로 이뤄진다.
<code class="docutils literal notranslate"><span class="pre">SimpleDense</span></code> 층을 이용하여 입력 데이터셋이 어떻게 변환되어 다음 층으로 전달되는 과정을 살펴본다.</p>
<p>아래 코드에서 <code class="docutils literal notranslate"><span class="pre">my_dense</span></code> 변수는 하나의 <code class="docutils literal notranslate"><span class="pre">SimpleDense</span></code> 층을 가리킨다.</p>
<ul class="simple">
<li><p>유닛 수: 512개</p></li>
<li><p>활성화 함수: <code class="docutils literal notranslate"><span class="pre">relu</span></code></p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_dense</span> <span class="o">=</span> <span class="n">SimpleDense</span><span class="p">(</span><span class="n">units</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">relu</span><span class="p">)</span>
</pre></div>
</div>
<p>아래 코드는 입력 배치 데이터셋으로 사용할 (128, 784) 모양의 텐서를 생성한다.</p>
<ul class="simple">
<li><p>128: 배치 크기</p></li>
<li><p>784: MNIST 데이터셋의 손글씨 이미지 한 장의 특성 수(<code class="docutils literal notranslate"><span class="pre">28</span> <span class="pre">*</span> <span class="pre">28</span> <span class="pre">=</span> <span class="pre">128</span></code>)</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">input_tensor</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">784</span><span class="p">))</span>
</pre></div>
</div>
<p>이제 <code class="docutils literal notranslate"><span class="pre">my_dense</span></code>를 함수 호출하듯이 사용하면 출력값이 계산된다.
즉, 포워드 패스가 실행된다.
층은 입렵 데이터셋을 처리할 때 입력 데이터셋의 모양을 확인하기에
굳이 입력 데이터셋에 대한 정보를 미리 요구하지 않는다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">output_tensor</span> <span class="o">=</span> <span class="n">my_dense</span><span class="p">(</span><span class="n">input_tensor</span><span class="p">)</span>
</pre></div>
</div>
<p>내부적으로는 <code class="docutils literal notranslate"><span class="pre">__call__()</span></code> 메서드가 호출되어 다음 사항들이 연속적으로 처리된다.</p>
<ul class="simple">
<li><p>가중치 텐서와 와 편향 텐서가 생성되지 않은 경우</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">(784,</span> <span class="pre">512)</span></code> 모양의 가중치 텐서 <code class="docutils literal notranslate"><span class="pre">W</span></code> 생성 및 무작위 초기화. 782는 입력 샘플의 특성 수, 512는 층의 유닛 수.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(512,</span> <span class="pre">)</span></code> 모양의 편향 텐서 <code class="docutils literal notranslate"><span class="pre">b</span></code> 생성 및 <code class="docutils literal notranslate"><span class="pre">0</span></code>으로 초기화. 512는 층의 유닛 수.</p></li>
<li><p>포워드 패스: 생성된 가중치와 편향을 이용하여 출력값 계산.</p></li>
</ul>
</li>
<li><p>가중치 텐서와 와 편향 텐서가 생성되어 있는 경우. 즉 훈련이 반복되는 경우.</p>
<ul>
<li><p>포워드 패스: 역전파로 업데이트된 가중치와 편향을 이용하여 출력값 계산.</p></li>
</ul>
</li>
</ul>
<p>층의 출력값은 <code class="docutils literal notranslate"><span class="pre">(128,</span> <span class="pre">32)</span></code> 모양의 텐서다.
이유는 각 데이터 샘플의 784개의 특성이 32개의 특성으로 변환되었기 때문이다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">output_tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(128, 512)</span>
</pre></div>
</div>
</section>
</div></section>
<section id="id9">
<h3><span class="section-number">4.3.2. </span>모델<a class="headerlink" href="#id9" title="Link to this heading">#</a></h3>
<p>앞서 살펴 본 <code class="docutils literal notranslate"><span class="pre">Sequential</span></code> 모델은 층을 일렬로 쌓는 모델이며
각각의 층은 이전 층에서 전달된 배치 데이터셋을 변환해서 다음 층으로 전달한다.</p>
<p><strong><code class="docutils literal notranslate"><span class="pre">tf.keras.Model</span></code> 클래스</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">Sequential</span></code> 클래스를 포함하여 케라스에서 지원되는 모든 모델 클래스는 <code class="docutils literal notranslate"><span class="pre">tf.keras.Model</span></code> 클래스를 상속한다.
예를 들어 <code class="docutils literal notranslate"><span class="pre">Sequential</span></code> 클래스를 이용하여 정의된 MNIST 분류 모델을 <code class="docutils literal notranslate"><span class="pre">SimpleDense</span></code> 층을 이용하여 직접 다음과 같이 정의할 수 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MySequential</span><span class="p">(</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_layers</span><span class="p">):</span> <span class="c1"># 층들의 리스트 지정</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_layers</span> <span class="o">=</span> <span class="n">list_layers</span>

    <span class="c1"># 포워드 패스: 층과 층을 연결하는 방식으로 구현</span>
    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">inputs</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_layers</span><span class="p">:</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">layer</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">outputs</span>
</pre></div>
</div>
<p>아래 두 개의 층을 이용하여 모델을 지정하고 다중 클래스 분류 모델에 맞게 모델을 컴파일한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">layer_1</span> <span class="o">=</span> <span class="n">SimpleDense</span><span class="p">(</span><span class="n">units</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">relu</span><span class="p">)</span>   <span class="c1"># 첫째 밀집층</span>
<span class="n">layer_2</span> <span class="o">=</span> <span class="n">SimpleDense</span><span class="p">(</span><span class="n">units</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">softmax</span><span class="p">)</span> <span class="c1"># 둘째 밀집층</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">MySequential</span><span class="p">([</span><span class="n">layer_1</span><span class="p">,</span> <span class="n">layer_2</span><span class="p">])</span>
</pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">직접 구현한 <code class="docutils literal notranslate"><span class="pre">Dense</span></code> 층과 케라스의 <code class="docutils literal notranslate"><span class="pre">Dense</span></code> 층의 차이점</p>
<p><code class="docutils literal notranslate"><span class="pre">keras.layers.Dense</span></code> 층을 이용한다면 다음과 같이 활성화 함수를 문자열로 지정할 수 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">layer_1</span> <span class="o">=</span> <span class="n">Dense</span><span class="p">(</span><span class="n">units</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">)</span>   <span class="c1"># 첫째 밀집층</span>
<span class="n">layer_2</span> <span class="o">=</span> <span class="n">Dense</span><span class="p">(</span><span class="n">units</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;softmax&#39;</span><span class="p">)</span> <span class="c1"># 둘째 밀집층</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">MySequential</span><span class="p">([</span><span class="n">layer_1</span><span class="p">,</span> <span class="n">layer_2</span><span class="p">])</span>
</pre></div>
</div>
</div>
<p><strong>모델을 하나의 층으로 활용하기</strong></p>
<p>기존에 정의된 모델을 다른 모델을 구성할 때 하나의 층으로 활용할 수도 있다.
이런 이유로 <code class="docutils literal notranslate"><span class="pre">tf.keras.Model</span></code> 클래스는 <code class="docutils literal notranslate"><span class="pre">tf.keras.layers.Layer</span></code> 클래스를
상속하도록 설계되어 있다.
<code class="docutils literal notranslate"><span class="pre">tf.keras.Model</span></code> 클래스의 활용법에 대한 보다 자세한 설명은 <a class="reference internal" href="working_with_keras.html#ch-working-with-keras"><span class="std std-numref">8장</span></a>을 참고한다.</p>
<p><strong>모델의 학습과정과 층의 구성</strong></p>
<p>모델의 학습과정은 전적으로 층의 구성방식에 의존한다.
그리고 층의 구성 방식은 주어진 데이터셋과 모델이 해결해야 하는 문제에 따라 달라진다.
층을 구성할 때 특별히 정해진 규칙은 없지만
문제 유형에 따른 권장 모델이 다양하게 개발되어 있다.</p>
<p>앞으로 보다 복잡하고 다양한 방식으로 층을 구성하는 방식들을 살펴볼 것이다.
예를 들어, 아래 그림은 <a class="reference internal" href="dl_for_text.html#ch-nlp"><span class="std std-numref">12장 자연어 처리</span></a>에서 소개하는
트랜스포머<font size='2'>Transformer</font> 모델의 복잡한 층 연결 구조를 보여준다.</p>
<div align="center"><img src="https://drek4537l1klr.cloudfront.net/chollet2/v-7/Figures/transformer0001.png" style="width:500px;"></div>
<p><div style="text-align: center">&lt;그림 출처: <a href="https://www.manning.com/books/deep-learning-with-python-second-edition">Deep Learning with Python(2판)</a>&gt;</div></p><p><strong>모델 컴파일</strong></p>
<p>선언된 모델을 훈련시키려면 다음 세 가지 설정을 추가로 지정해야 한다.</p>
<ul class="simple">
<li><p>손실 함수</p>
<ul>
<li><p>훈련 중 모델의 성능이 얼마나 나쁜지 측정.</p></li>
<li><p>가중치와 편향 의존하는 함수</p></li>
<li><p>가중치와 편향에 대해 미분 가능해야 함.</p></li>
<li><p>옵티마이저가 역전파를 통해 모델의 성능을 향상시키는 방향으로 모델의 가중치를 업데이트할 때 참고하는 함수임.</p></li>
</ul>
</li>
<li><p>옵티마이저</p>
<ul>
<li><p>가중치와 편향을 업데이트하는 역전파 반복 실행</p></li>
</ul>
</li>
<li><p>평가지표</p>
<ul>
<li><p>훈련과 테스트 과정을 모니터링 할 때 사용되는 모델 평가 지표.</p></li>
<li><p>손실 함수와는 달리 훈련에 사용되지 않음.</p></li>
<li><p>단순히 모델 성능 평가에 사용됨.</p></li>
</ul>
</li>
</ul>
<p>케라스에서 기본으로 제공하는 옵티마이저, 손실 함수, 평가지표는 문자열로 지정할 수 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">)])</span>
<span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s2">&quot;rmsprop&quot;</span><span class="p">,</span>
              <span class="n">loss</span><span class="o">=</span><span class="s2">&quot;mean_squared_error&quot;</span><span class="p">,</span>
              <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;accuracy&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>각각의 문자열은 특정 파이썬 객체를 가리킨다.</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head text-left"><p>문자열</p></th>
<th class="head text-left"><p>파이썬 객체</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-left"><p><code class="docutils literal notranslate"><span class="pre">&quot;rmsprop&quot;</span></code></p></td>
<td class="text-left"><p><code class="docutils literal notranslate"><span class="pre">keras.optimizers.RMSprop()</span></code></p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p><code class="docutils literal notranslate"><span class="pre">&quot;mean_squared_error&quot;</span></code></p></td>
<td class="text-left"><p><code class="docutils literal notranslate"><span class="pre">keras.losses.MeanSquaredError()</span></code></p></td>
</tr>
<tr class="row-even"><td class="text-left"><p><code class="docutils literal notranslate"><span class="pre">&quot;accuracy&quot;</span></code></p></td>
<td class="text-left"><p><code class="docutils literal notranslate"><span class="pre">keras.metrics.BinaryAccuracy()]</span></code></p></td>
</tr>
</tbody>
</table>
</div>
<p>따라서 지정된 문자열을 사용하는 대신 파이썬 객체를 직접 지정해도 된다.
만약 사용자가 직접 구현한 클래스의 객체를 이용하려면
앞서 <code class="docutils literal notranslate"><span class="pre">SimpleDense</span></code>를 통해 본 것처럼 적절한 클래스를 상속하면서
동시에 필수 메서드를 모두 적절하게 재정의해야<font size='2'>overriding</font> 한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="o">.</span><span class="n">optimizers</span><span class="o">.</span><span class="n">RMSprop</span><span class="p">(),</span>
              <span class="n">loss</span><span class="o">=</span><span class="n">keras</span><span class="o">.</span><span class="n">losses</span><span class="o">.</span><span class="n">MeanSquaredError</span><span class="p">(),</span>
              <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="n">keras</span><span class="o">.</span><span class="n">metrics</span><span class="o">.</span><span class="n">BinaryAccuracy</span><span class="p">()])</span>
</pre></div>
</div>
<p>다음 두 가지의 경우엔 문자열 대신 해당 객체를 지정해야 한다.</p>
<ul class="simple">
<li><p>예를 들어, 기본값과 다른 학습률(<code class="docutils literal notranslate"><span class="pre">learning_rate</span></code>)을 사용하는 옵티마이저를 지정하는 경우</p></li>
<li><p>사용자가 직접 정의한 객체를 사용하는 경우</p></li>
</ul>
<p>아래 코드는 직접 객체를 지정하는 방식으로 모델을 컴파일하는 형식을 보여준다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="o">.</span><span class="n">optimizers</span><span class="o">.</span><span class="n">RMSprop</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">),</span>
              <span class="n">loss</span><span class="o">=</span><span class="n">사용자정의손실함수객체</span><span class="p">,</span>
              <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="n">사용자정의평가지표_1</span><span class="p">,</span> <span class="n">사용자정의평가지표_2</span><span class="p">])</span>
</pre></div>
</div>
<p>일반적으로 가장 많이 사용되는 옵티마이저, 손실함수, 평가지표는 다음과 같으며
앞으로 다양한 예제를 통해 적절한 옵티마이저, 손실함수, 평가지표를 선택하는 방법을 살펴볼 것이다.</p>
<p>옵티마이저: 다양한 옵티마이저의 장단점에 대해서는 <a class="reference external" href="https://www.oreilly.com/library/view/hands-on-machine-learning/9781098125967/">Hands-on Machine Learning 3판</a>의 11장에 정리되어 있다.</p>
<ul class="simple">
<li><p>SGD</p></li>
<li><p>SGD + momentum</p></li>
<li><p>Adagrad</p></li>
<li><p>RMSprop</p></li>
<li><p>Adam</p></li>
<li><p>Nadam</p></li>
<li><p>AdamW</p></li>
</ul>
<p>등등.</p>
<p>손실 함수: 일반적으로 모델의 종류에 따라 손실 함수를 선택한다.</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head text-center"><p>손실 함수</p></th>
<th class="head text-center"><p>용도</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>CategoricalCrossentropy</p></td>
<td class="text-center"><p>다중 클래스 분류</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>SparseCategoricalCrossentropy</p></td>
<td class="text-center"><p>다중 클래스 분류. 정수형 (벡터) 타깃</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>BinaryCrossentropy</p></td>
<td class="text-center"><p>이진 분류</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>MeanSquaredError</p></td>
<td class="text-center"><p>회귀</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>KLDivergence</p></td>
<td class="text-center"><p>다중 클래스 분류</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>CosineSimilarity</p></td>
<td class="text-center"><p>회귀와 분류 모두. 문장 번역, 물건 추천, 이미지 분류 등</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>등등</p></td>
<td class="text-center"><p></p></td>
</tr>
</tbody>
</table>
</div>
<p>평가지표: 일반적으로 모델 종류와 목적에 따라 평가 지표를 선택한다.</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head text-center"><p>평가지표</p></th>
<th class="head text-center"><p>용도</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>CategoricalAccuracy</p></td>
<td class="text-center"><p>다중클래스 분류 정확도  측정</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>SparseCategoricalAccuracy</p></td>
<td class="text-center"><p>다중클래스 분류 정확도. 정수형 (벡터) 타깃 사용</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>BinaryAccuracy</p></td>
<td class="text-center"><p>이진 분류 정확도 측정</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>AUC</p></td>
<td class="text-center"><p>다중 클래스 분류 AUC 측정</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>Precision</p></td>
<td class="text-center"><p>다중 클래스 분류 정밀도 측정</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>Recall</p></td>
<td class="text-center"><p>다중 클래스 분류 재현율 측정</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>등등</p></td>
<td class="text-center"><p></p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="id10">
<h3><span class="section-number">4.3.3. </span>훈련 루프<a class="headerlink" href="#id10" title="Link to this heading">#</a></h3>
<p>모델을 컴파일한 다음에 <code class="docutils literal notranslate"><span class="pre">fit()</span></code> 메서드를 호출하면
모델은 스텝 단위로 반복되는 <strong>훈련 루프</strong><font size='2'>training loop</font>가 작동한다.
지정된 에포크 만큼 또는 학습이 충분히 이루어졌다는 평가가 내려질 때까지
훈련을 반복한다.</p>
<p><strong>지도학습 모델 훈련</strong></p>
<p>모델을 훈련시키려면 <code class="docutils literal notranslate"><span class="pre">fit()</span></code> 메서드를 적절한 인자들과 함께 호출해야 한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">training_history</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
    <span class="n">inputs</span><span class="p">,</span>
    <span class="n">targets</span><span class="p">,</span>
    <span class="n">epochs</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="mi">128</span>
<span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>(지도 학습 모델의 경우) 훈련셋(inputs)과 타깃셋(targets): 보통 넘파이 어레이 또는 텐서플로우의 <code class="docutils literal notranslate"><span class="pre">Dataset</span></code> 객체 사용</p></li>
<li><p>에포크(<code class="docutils literal notranslate"><span class="pre">epochs</span></code>): 전체 훈련 세트를 몇 번 훈련할 지 지정</p></li>
<li><p>배치 크기(<code class="docutils literal notranslate"><span class="pre">batch_size</span></code>): 하나의 스텝 과정에서 사용되는 데이터 묶음(배치)의 크기</p></li>
</ul>
<p><strong><code class="docutils literal notranslate"><span class="pre">History</span></code> 객체: 훈련 결과</strong></p>
<p>모델의 훈련 결과로 <code class="docutils literal notranslate"><span class="pre">History</span></code> 객체가 반환된다.
예를 들어 <code class="docutils literal notranslate"><span class="pre">History</span></code> 객체의 <code class="docutils literal notranslate"><span class="pre">history</span></code> 속성은 에포크별로 계산된 손실값과 평가지표값을
사전 자료형으로 가리킨다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">training_history</span><span class="o">.</span><span class="n">history</span>
<span class="go">{&#39;loss&#39;: [0.2729695439338684,</span>
<span class="go">  0.11179507523775101,</span>
<span class="go">  0.07302209734916687,</span>
<span class="go">  0.0526457279920578,</span>
<span class="go">  0.04022042825818062],</span>
<span class="go"> &#39;accuracy&#39;: [0.9212833046913147,</span>
<span class="go">  0.9672333598136902,</span>
<span class="go">  0.9783666729927063,</span>
<span class="go">  0.9844833612442017,</span>
<span class="go">  0.988099992275238]}</span>
</pre></div>
</div>
<p><strong>검증 데이터 활용</strong></p>
<p>머신러닝 모델 훈련의 목표는 훈련셋에 대한 높은 성능이 아니라
훈련에서 보지 못한 새로운 데이터에 대한 정확한 예측이다.
훈련 중에 또는 훈련이 끝난 후에 모델이 새로운 데이터에 대해 정확한 예측을 하는지
여부를 판단하도록 할 수 있다.</p>
<p>이를 위해 전체 데이터셋을 훈련셋과 검증셋<font size='2'>validation dataset</font>으로 구분한다.
훈련셋과 검증셋의 비율은 보통 8대2 또는 7대3 정도로 하지만
훈련셋이 매우 크다면 검증셋의 비율을 보다 적게 잡을 수 있다.
훈련셋 자체가 매우 작은 경우엔 검증셋을 따로 분리하기 보다는 K-겹 교차 검증 등을 사용해야 한다.</p>
<p>훈련셋과 검증셋이 서로 겹치지 않도록 주의해야 한다.
그렇지 않으면 훈련 중에 모델이 검증셋에 포함된 데이터를 학습하기에
정확환 모델 평가를 할 수 없게 된다.</p>
<p><em>훈련 중 모델 검증</em></p>
<p>아래 코드는 미리 지정된 검증셋 <code class="docutils literal notranslate"><span class="pre">val_inputs</span></code>와 검증 타깃값 <code class="docutils literal notranslate"><span class="pre">val_targets</span></code>를
<code class="docutils literal notranslate"><span class="pre">validation_data</span></code>의 키워드 인자로 지정해서
모델 훈련 중에 에포크 단위로 측정하도록 한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
    <span class="n">training_inputs</span><span class="p">,</span>
    <span class="n">training_targets</span><span class="p">,</span>
    <span class="n">epochs</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
    <span class="n">validation_data</span><span class="o">=</span><span class="p">(</span><span class="n">val_inputs</span><span class="p">,</span> <span class="n">val_targets</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>검증셋에 대한 손실값과 정확도도 훈련중에 계산된다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">training_history</span><span class="o">.</span><span class="n">history</span>
<span class="go">{&#39;loss&#39;: [0.02950882911682129,</span>
<span class="go">  0.021471761167049408,</span>
<span class="go">  0.015012570656836033,</span>
<span class="go">  0.011033009737730026,</span>
<span class="go">  0.0080801947042346],</span>
<span class="go"> &#39;accuracy&#39;: [0.991428554058075,</span>
<span class="go">  0.9937618970870972,</span>
<span class="go">  0.9962857365608215,</span>
<span class="go">  0.9974523782730103,</span>
<span class="go">  0.9982380867004395],</span>
<span class="go"> &#39;val_loss&#39;: [0.029974577948451042,</span>
<span class="go">  0.03373847156763077,</span>
<span class="go">  0.03262251615524292,</span>
<span class="go">  0.03768538683652878,</span>
<span class="go">  0.03493628650903702],</span>
<span class="go"> &#39;val_accuracy&#39;: [0.9906111359596252,</span>
<span class="go">  0.9896666407585144,</span>
<span class="go">  0.9901666641235352,</span>
<span class="go">  0.9882222414016724,</span>
<span class="go">  0.9900555610656738]}</span>
</pre></div>
</div>
<p><em>훈련 후 모델 검증</em></p>
<p>훈련이 끝난 모델의 성능 검증하려면 <code class="docutils literal notranslate"><span class="pre">evaluate()</span></code> 메서드를 이용한다.
배치 크기(<code class="docutils literal notranslate"><span class="pre">batch_size</span></code>)를 지정하여 배치 단위로 학습하도록 한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">loss_and_metrics</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">val_inputs</span><span class="p">,</span> <span class="n">val_targets</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>
</pre></div>
</div>
<p>반환값으로 지정된 손실값과 평가지표를 담은 리스트가 생성된다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">loss_and_metrics</span><span class="p">)</span>
<span class="go">[0.29411643743515015, 0.5333333611488342]</span>
</pre></div>
</div>
</section>
<section id="id11">
<h3><span class="section-number">4.3.4. </span>예측<a class="headerlink" href="#id11" title="Link to this heading">#</a></h3>
<p>모델의 훈련과 검증이 완료되면 실전에서 새로운 데이터에 대한 예측을 진행한다.
데이터셋에 포함된 모든 데이터에 대한 예측을 한 번에 실행할 수 있으며
두 가지 방식이 존재한다.</p>
<p><strong>모델 적용</strong></p>
<p>모델을 마치 함수처럼 이용한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">predictions</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">new_inputs</span><span class="p">)</span>
</pre></div>
</div>
<p>내부적으론 앞서 설명한 <code class="docutils literal notranslate"><span class="pre">__call()__</span></code> 메서드가 실행된다.
따라서 <code class="docutils literal notranslate"><span class="pre">call()</span></code> 메서드를 사용하는 포워드 패스가 실행되어
예측값이 계산된다.</p>
<p>하지만 이 방식은 입력 데이터셋 전체를 대상으로 한 번에 계산하기에
데이터셋이 너무 크면 계산이 너무 오래 걸리거나 메모리가 부족해질 수 있다.
따라서 배치를 활용하는 <code class="docutils literal notranslate"><span class="pre">predict()</span></code> 메서드를 활용할 것을 추천한다.</p>
<p><strong><code class="docutils literal notranslate"><span class="pre">predict()</span></code> 메서드</strong></p>
<p>훈련된 모델의 <code class="docutils literal notranslate"><span class="pre">predict()</span></code> 메서드는 배치 크기를 지정하면
배치 단위로 예측값을 계산한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">predictions</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">new_inputs</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="id12">
<h2><span class="section-number">4.4. </span>연습 문제<a class="headerlink" href="#id12" title="Link to this heading">#</a></h2>
<ol class="arabic simple">
<li><p><a class="reference external" href="https://colab.research.google.com/github/codingalzi/dlp2/blob/master/excs/exc-keras_and_tf.ipynb">(실습) 케라스와 텐서플로우</a></p></li>
</ol>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="tf_tensor.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">3. </span>텐서</p>
      </div>
    </a>
    <a class="right-next"
       href="getting_started_with_neural_networks.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">5. </span>신경망 활용 처음부터 끝까지: 분류와 회귀</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">4.1. 딥러닝 주요 라이브러리</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">4.1.1. 텐서플로우</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">4.1.2. 케라스</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">4.1.3. 딥러닝 주요 라이브러리 약력</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">4.1.4. 딥러닝 개발환경</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">4.2. 텐서플로우 활용법 기초</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#api">4.3. 케라스 신경망 모델의 핵심 API</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">4.3.1. 층</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">4.3.2. 모델</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">4.3.3. 훈련 루프</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">4.3.4. 예측</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">4.4. 연습 문제</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By 코딩알지
</p>

  </div>
  
  <div class="footer-item">
    

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>